--- a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
+++ b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
@@ -133,7 +133,7 @@ inline Type* LegalizedIntVectorType(Modu
 
     return ty->isIntegerTy() ?
         cast<Type>(IntegerType::get(M.getContext(), newSize)) :
-        IGCLLVM::FixedVectorType::get(IntegerType::get(M.getContext(), newSize), (unsigned)cast<VectorType>(ty)->getNumElements());
+        IGCLLVM::FixedVectorType::get(IntegerType::get(M.getContext(), newSize), (unsigned)cast<IGCLLVM::FixedVectorType>(ty)->getNumElements());
 }
 
 // Returns true for small structures that only contain primitive types
--- a/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
+++ b/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
@@ -1610,7 +1610,7 @@ void SPIRVToLLVMDbgTran::transDbgInfo(SP
             Line->getColumn(), scope, iat);
 
         if(scope && !isa<DIFile>(scope))
-            I->setDebugLoc(DebugLoc::get(Line->getLine(), Line->getColumn(),
+            I->setDebugLoc(DILocation::get(scope->getContext(), Line->getLine(), Line->getColumn(),
                 scope, iat));
     }
 }
@@ -2063,7 +2063,7 @@ SPIRVToLLVM::transType(SPIRVType *T) {
         auto name = isSubgroupAvcINTELTypeOpCode(OC) ?
             OCLSubgroupINTELTypeOpCodeMap::rmap(OC) :
             BuiltinOpaqueGenericTypeOpCodeMap::rmap(OC);
-        auto *pST = M->getTypeByName(name);
+        auto *pST = IGCLLVM::getTypeByName(M, name);
         pST = pST ? pST : StructType::create(*Context, name);
 
         return mapType(T, PointerType::get(pST, getOCLOpaqueTypeAddrSpace(OC)));
@@ -2541,7 +2541,7 @@ Value *SPIRVToLLVM::promoteBool(Value *p
 
     auto *PromoType = isa<VectorType>(pVal->getType()) ?
         cast<Type>(IGCLLVM::FixedVectorType::get(Type::getInt8Ty(pVal->getContext()),
-        (unsigned)cast<VectorType>(pVal->getType())->getNumElements())) :
+        (unsigned)cast<IGCLLVM::FixedVectorType>(pVal->getType())->getNumElements())) :
         Type::getInt8Ty(pVal->getContext());
 
     if (auto *C = dyn_cast<Constant>(pVal))
@@ -2583,7 +2583,7 @@ Value *SPIRVToLLVM::truncBool(Value *pVa
 
     auto *TruncType = isa<VectorType>(pVal->getType()) ?
         cast<Type>(IGCLLVM::FixedVectorType::get(Type::getInt1Ty(pVal->getContext()),
-            (unsigned)cast<VectorType>(pVal->getType())->getNumElements())) :
+            (unsigned)cast<IGCLLVM::FixedVectorType>(pVal->getType())->getNumElements())) :
         Type::getInt1Ty(pVal->getContext());
 
     if (auto *C = dyn_cast<Constant>(pVal))
@@ -2629,7 +2629,7 @@ Type *SPIRVToLLVM::truncBoolType(SPIRVTy
 
     return isa<VectorType>(LLType) ?
         cast<Type>(IGCLLVM::FixedVectorType::get(Type::getInt1Ty(LLType->getContext()),
-                                   (unsigned)cast<VectorType>(LLType)->getNumElements())) :
+                                   (unsigned)cast<IGCLLVM::FixedVectorType>(LLType)->getNumElements())) :
         Type::getInt1Ty(LLType->getContext());
 }
 
@@ -2837,7 +2837,7 @@ SPIRVToLLVM::transValueWithoutDecoration
       {
         if(CV[i]->getType()->isVectorTy())
         {
-          for(uint32_t j = 0; j < cast<VectorType>(CV[i]->getType())->getNumElements(); j++)
+          for(uint32_t j = 0; j < cast<IGCLLVM::FixedVectorType>(CV[i]->getType())->getNumElements(); j++)
           {
             Value *v = ExtractElementInst::Create( CV[i],ConstantInt::get( *Context,APInt( 32,j ) ),BCC->getName(),BB );
             elm1 = CreateCompositeConstruct( elm1,v,pos++ );
@@ -3508,7 +3508,7 @@ SPIRVToLLVM::transValueWithoutDecoration
       auto Vector = transValue(BI->getOperand(0), F, BB);
       auto Scalar = transValue(BI->getOperand(1), F, BB);
 
-      auto VecType = cast<VectorType>(Vector->getType());
+      auto VecType = cast<IGCLLVM::FixedVectorType>(Vector->getType());
       auto Undef   = UndefValue::get(VecType);
 
       auto ScalarVec = InsertElementInst::Create(Undef, Scalar,
@@ -3533,7 +3533,7 @@ SPIRVToLLVM::transValueWithoutDecoration
           a->getType()->getScalarSizeInBits() - 1);
       auto *ShiftOp = isa<VectorType>(a->getType()) ?
           ConstantVector::getSplat(
-              IGCLLVM::getElementCount((unsigned)cast<VectorType>(a->getType())->getNumElements()), ShiftAmt) :
+              IGCLLVM::getElementCount((unsigned)cast<IGCLLVM::FixedVectorType>(a->getType())->getNumElements()), ShiftAmt) :
           ShiftAmt;
 
       // OCL C:
@@ -3887,15 +3887,15 @@ SPIRVToLLVM::transSPIRVBuiltinFromInst(S
               "",
               BB);
       }
-      else if (cast<VectorType>(coordType)->getNumElements() != 4)
+      else if (cast<IGCLLVM::FixedVectorType>(coordType)->getNumElements() != 4)
       {
           Value *undef = UndefValue::get(coordType);
 
           SmallVector<Constant*, 4> shuffleIdx;
-          for (unsigned i = 0; i < cast<VectorType>(coordType)->getNumElements(); i++)
+          for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(coordType)->getNumElements(); i++)
               shuffleIdx.push_back(ConstantInt::get(Type::getInt32Ty(*Context), i));
 
-          for (uint64_t i = (unsigned)cast<VectorType>(coordType)->getNumElements(); i < 4; i++)
+          for (uint64_t i = (unsigned)cast<IGCLLVM::FixedVectorType>(coordType)->getNumElements(); i < 4; i++)
               shuffleIdx.push_back(ConstantInt::get(Type::getInt32Ty(*Context), 0));
 
           imageCoordinateWiden = new ShuffleVectorInst(
--- a/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
+++ b/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
@@ -76,7 +76,7 @@ saveLLVMModule(Module *M, const std::str
 PointerType*
 getOrCreateOpaquePtrType(Module *M, const std::string &Name,
     unsigned AddrSpace) {
-  auto OpaqueType = M->getTypeByName(Name);
+  auto OpaqueType = IGCLLVM::getTypeByName(M, Name);
   if (!OpaqueType)
     OpaqueType = StructType::create(M->getContext(), Name);
   return PointerType::get(OpaqueType, AddrSpace);
@@ -142,7 +142,7 @@ std::string recursive_mangle(const Type*
             return "i" + utostr(pType->getIntegerBitWidth());
         case IGCLLVM::VectorTyID:
         {
-            unsigned vecLen = (unsigned)cast<VectorType>(pType)->getNumElements();
+            unsigned vecLen = (unsigned)cast<IGCLLVM::FixedVectorType>(pType)->getNumElements();
             Type* pEltType = cast<VectorType>(pType)->getElementType();
             return "v" + utostr(vecLen) + recursive_mangle(pEltType);
         }
--- a/IGC/Compiler/CISACodeGen/AdvMemOpt.cpp
+++ b/IGC/Compiler/CISACodeGen/AdvMemOpt.cpp
@@ -17,6 +17,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/raw_ostream.h>
 #include <llvm/Transforms/Utils/Local.h>
+#include "llvmWrapper/Transforms/Utils/LoopUtils.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 #include "Compiler/CISACodeGen/ShaderCodeGen.hpp"
@@ -118,7 +119,7 @@ bool AdvMemOpt::runOnFunction(Function&
     for (auto I = LI->begin(), E = LI->end(); I != E; ++I)
         for (auto DFI = df_begin(*I), DFE = df_end(*I); DFI != DFE; ++DFI) {
             Loop* L = *DFI;
-            if (L->empty())
+            if (IGCLLVM::isInnermost(L))
                 InnermostLoops.push_back(L);
         }
 
--- a/IGC/Compiler/CISACodeGen/CShader.cpp
+++ b/IGC/Compiler/CISACodeGen/CShader.cpp
@@ -427,7 +427,7 @@ void CShader::CreateAliasVars()
                         continue;
 
                     Type* Ty = V->getType();
-                    VectorType* VTy = dyn_cast<VectorType>(Ty);
+                    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
                     Type* BTy = VTy ? VTy->getElementType() : Ty;
                     int nelts = (VTy ? (int)VTy->getNumElements() : 1);
 
@@ -1039,7 +1039,7 @@ bool CShader::InsideThreadDivergentCF(co
 uint CShader::GetNbVectorElementAndMask(llvm::Value* val, uint32_t& mask)
 {
     llvm::Type* type = val->getType();
-    uint nbElement = int_cast<uint>(cast<VectorType>(type)->getNumElements());
+    uint nbElement = int_cast<uint>(cast<IGCLLVM::FixedVectorType>(type)->getNumElements());
     mask = 0;
     // we don't process vector bigger than 31 elements as the mask has only 32bits
     // If we want to support longer vectors we need to extend the mask size
@@ -1244,7 +1244,7 @@ CShader::ExtractMaskWrapper::ExtractMask
         m_EM = it->second;
         return;
     }
-    VectorType* VTy = dyn_cast<VectorType>(VecVal->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(VecVal->getType());
     const unsigned int numChannels = VTy ? (unsigned)VTy->getNumElements() : 1;
     if (numChannels <= 32)
     {
@@ -1768,7 +1768,7 @@ CVariable* CShader::GetStructVariable(ll
 
 CVariable* CShader::GetConstant(llvm::Constant* C, CVariable* dstVar)
 {
-    llvm::VectorType* VTy = llvm::dyn_cast<llvm::VectorType>(C->getType());
+    IGCLLVM::FixedVectorType* VTy = llvm::dyn_cast<IGCLLVM::FixedVectorType>(C->getType());
     if (C && VTy)
     {   // Vector constant
         llvm::Type* eTy = VTy->getElementType();
@@ -1996,7 +1996,7 @@ uint32_t CShader::GetNumElts(llvm::Type*
     {
         IGC_ASSERT(type->getContainedType(0)->isIntegerTy() || type->getContainedType(0)->isFloatingPointTy());
 
-        auto VT = cast<VectorType>(type);
+        auto VT = cast<IGCLLVM::FixedVectorType>(type);
         numElts *= (uint16_t)VT->getNumElements();
     }
     else if (type->isStructTy())
@@ -2713,7 +2713,7 @@ CVariable* CShader::GetSymbol(llvm::Valu
                 if (isVecType)
                 {
                     // Map the entire vector value to the CVar
-                    unsigned numElements = (unsigned)cast<VectorType>(value->getType())->getNumElements();
+                    unsigned numElements = (unsigned)cast<IGCLLVM::FixedVectorType>(value->getType())->getNumElements();
                     var = GetNewVariable(numElements, ISA_TYPE_UQ,
                         (GetContext()->platform.getGRFSize() == 64) ? EALIGN_32WORD : EALIGN_HWORD,
                         WIBaseClass::UNIFORM_GLOBAL, 1, valName);
@@ -3623,7 +3623,7 @@ unsigned int CShader::GetPrimitiveTypeSi
     {
         sizeInBits =
             GetContext()->getRegisterPointerSizeInBits(Ty->getPointerAddressSpace());
-        if (auto* VTy = dyn_cast<VectorType>(Ty))
+        if (auto* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty))
         {
             sizeInBits *= (unsigned)VTy->getNumElements();
         }
--- a/IGC/Compiler/CISACodeGen/ConstantCoalescing.cpp
+++ b/IGC/Compiler/CISACodeGen/ConstantCoalescing.cpp
@@ -206,7 +206,7 @@ static void checkInsertExtractMatch(Inse
 
 static bool canReplaceInsert(InsertElementInst* insertElt)
 {
-    VectorType* VTy = cast<VectorType>(insertElt->getOperand(0)->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(insertElt->getOperand(0)->getType());
     ConstantInt* index = dyn_cast<ConstantInt>(insertElt->getOperand(2));
     if (!index || index->getZExtValue() != VTy->getNumElements() - 1)
     {
@@ -294,7 +294,7 @@ void ConstantCoalescing::VectorizePrep(l
         {
             if (load->getType()->isVectorTy() && wiAns->isUniform(load))
             {
-                srcNElts = (uint32_t)cast<VectorType>(load->getType())->getNumElements();
+                srcNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(load->getType())->getNumElements();
                 DenseMap<uint64_t, Instruction*> extractElementMap;
 
                 for (auto iter = load->user_begin(); iter != load->user_end(); iter++)
@@ -378,7 +378,7 @@ bool ConstantCoalescing::isProfitableLoa
             (isa<LoadInst>(I) && wiAns->isUniform(I)) ?
             16 : 4;
 
-        if (cast<VectorType>(LoadTy)->getNumElements() > MaxVectorInput)
+        if (cast<IGCLLVM::FixedVectorType>(LoadTy)->getNumElements() > MaxVectorInput)
             return false;
 
         MaxEltPlus = CheckVectorElementUses(I);
@@ -1957,7 +1957,7 @@ void ConstantCoalescing::AdjustChunk(Buf
         WIAnalysis::WIDependancy loadDep = wiAns->whichDepend(cov_chunk->chunkIO);
         irBuilder->SetInsertPoint(cov_chunk->chunkIO->getNextNode());
         Value* vec = UndefValue::get(originalType);
-        for (unsigned i = 0; i < cast<VectorType>(originalType)->getNumElements(); i++)
+        for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(originalType)->getNumElements(); i++)
         {
             Value* channel = irBuilder->CreateExtractElement(
                 cov_chunk->chunkIO, irBuilder->getInt32(i + start_adj));
@@ -2021,7 +2021,7 @@ void ConstantCoalescing::MoveExtracts(Bu
             irBuilder->SetInsertPoint(load->getNextNode());
             Type* vecType = load->getType();
             Value* vec = UndefValue::get(vecType);
-            for (unsigned i = 0; i < cast<VectorType>(vecType)->getNumElements(); i++)
+            for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(vecType)->getNumElements(); i++)
             {
                 Value* channel = irBuilder->CreateExtractElement(
                     cov_chunk->chunkIO, irBuilder->getInt32(i + start_adj));
@@ -2085,7 +2085,7 @@ void ConstantCoalescing::EnlargeChunk(Bu
         WIAnalysis::WIDependancy loadDep = wiAns->whichDepend(cov_chunk->chunkIO);
         irBuilder->SetInsertPoint(cov_chunk->chunkIO->getNextNode());
         Value* vec = UndefValue::get(originalType);
-        for (unsigned i = 0; i < cast<VectorType>(originalType)->getNumElements(); i++)
+        for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(originalType)->getNumElements(); i++)
         {
             Value* channel = irBuilder->CreateExtractElement(
                 cov_chunk->chunkIO, irBuilder->getInt32(i));
@@ -2522,7 +2522,7 @@ void ConstantCoalescing::ReplaceLoadWith
         if (dstTy->isVectorTy())
         {
             result = UndefValue::get(dstTy);
-            for (uint i = 0; i < cast<VectorType>(dstTy)->getNumElements(); i++)
+            for (uint i = 0; i < cast<IGCLLVM::FixedVectorType>(dstTy)->getNumElements(); i++)
             {
                 Value* tmpData = ExtractFromSamplerData(cast<VectorType>(dstTy)->getElementType(), i);
                 result = irBuilder->CreateInsertElement(result, tmpData, irBuilder->getInt32(i));
--- a/IGC/Compiler/CISACodeGen/DeSSA.cpp
+++ b/IGC/Compiler/CISACodeGen/DeSSA.cpp
@@ -68,6 +68,7 @@ See LICENSE.TXT for details.
 #include "llvmWrapper/IR/Instructions.h"
 #include <llvm/IR/InstIterator.h>
 #include <llvm/IR/InlineAsm.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include <algorithm>
 #include "Probe/Assertion.h"
@@ -1302,7 +1303,7 @@ int DeSSA::checkInsertElementAlias(
     //
     // If found, return the actual vector size;
     // otherwise, return 0.
-    VectorType* VTy = cast<VectorType>(IEI->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(IEI->getType());
     IGC_ASSERT(nullptr != VTy);
     int nelts = (int)VTy->getNumElements();
     AllIEIs.resize(nelts, nullptr);
--- a/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
+++ b/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
@@ -1265,7 +1265,7 @@ bool EmitPass::canRelocatePhiMov(
                 if (dst != src)
                 {
                     int numElt = 1;
-                    if (VectorType * vTy = dyn_cast<VectorType>(PN->getType()))
+                    if (IGCLLVM::FixedVectorType * vTy = dyn_cast<IGCLLVM::FixedVectorType>(PN->getType()))
                     {
                         numElt = int_cast<int>(vTy->getNumElements());
                     }
@@ -1402,7 +1402,7 @@ void EmitPass::MovPhiSources(llvm::Basic
                         phiSrcDstList.push_back(phiInfo);
 
                         int numElt = 0;
-                        if (VectorType * vTy = dyn_cast<VectorType>(PN->getType()))
+                        if (IGCLLVM::FixedVectorType * vTy = dyn_cast<IGCLLVM::FixedVectorType>(PN->getType()))
                         {
                             numElt = int_cast<int>(vTy->getNumElements());
                         }
@@ -5606,7 +5606,7 @@ void EmitPass::emitLegacySimdBlockWrite(
     bool useA64 = isA64Ptr(ptrType, m_currShader->GetContext());
 
     Type* Ty = dataPtr->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     uint32_t nbElements = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
 
     uint32_t typeSizeInBytes = Ty->getScalarSizeInBits() / 8;
@@ -5852,7 +5852,7 @@ void EmitPass::emitLegacySimdBlockRead(l
     bool useA64 = isA64Ptr(ptrType, m_currShader->GetContext());
 
     Type* Ty = inst->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     uint32_t nbElements = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
 
     uint32_t typeSizeInBytes = Ty->getScalarSizeInBits() / 8;
@@ -6144,7 +6144,7 @@ void EmitPass::emitMediaBlockIO(const ll
         };
 
         uint nElts = isa<VectorType>(pDataType) ?
-            (uint)cast<VectorType>(pDataType)->getNumElements() :
+            (uint)cast<IGCLLVM::FixedVectorType>(pDataType)->getNumElements() :
             1;
 
         // Now, do the copies.
@@ -6234,7 +6234,7 @@ void EmitPass::emitSimdMediaBlockRead(ll
     uint32_t nbElements = 1;
     if (inst->getType()->isVectorTy())
     {
-        nbElements = (uint32_t)cast<VectorType>(inst->getType())->getNumElements();
+        nbElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements();
     }
     IGC_ASSERT_MESSAGE(nbElements <= 8, "InValid Vector Size");
 
@@ -6478,7 +6478,7 @@ void EmitPass::emitSimdMediaBlockWrite(l
     uint32_t nbElements = 1;
     if (dataPtr->getType()->isVectorTy())
     {
-        nbElements = (uint32_t)cast<VectorType>(dataPtr->getType())->getNumElements();
+        nbElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(dataPtr->getType())->getNumElements();
     }
     IGC_ASSERT_MESSAGE(nbElements <= 8, "InValid Vector Size");
 
@@ -9134,7 +9134,7 @@ void EmitPass::EmitInlineAsm(llvm::CallI
                 {
                     if (inst->getType()->isVectorTy())
                     {
-                        emitVectorCopy(dest, cv, int_cast<unsigned>(dyn_cast<VectorType>(inst->getType())->getNumElements()));
+                        emitVectorCopy(dest, cv, int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements()));
                     }
                     else
                     {
@@ -9409,8 +9409,8 @@ void EmitPass::emitBitCast(llvm::BitCast
 {
     Type* srcType = btCst->getOperand(0)->getType();
     Type* dstType = btCst->getType();
-    unsigned int numSrcElement = srcType->isVectorTy() ? (unsigned)cast<VectorType>(srcType)->getNumElements() : 1;
-    unsigned int numDstElement = dstType->isVectorTy() ? (unsigned)cast<VectorType>(dstType)->getNumElements() : 1;
+    unsigned int numSrcElement = srcType->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(srcType)->getNumElements() : 1;
+    unsigned int numDstElement = dstType->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(dstType)->getNumElements() : 1;
 
     if (srcType->isPointerTy())
     {
@@ -9857,7 +9857,7 @@ void EmitPass::emitLoad3DInner(LdRawIntr
     {
         IGC_ASSERT_MESSAGE(predDefSurface != ESURFACE_STATELESS, "scratch cannot be uniform");
         Type* loadType = inst->getType();
-        uint numElement = loadType->isVectorTy() ? (uint)cast<VectorType>(loadType)->getNumElements() : 1;
+        uint numElement = loadType->isVectorTy() ? (uint)cast<IGCLLVM::FixedVectorType>(loadType)->getNumElements() : 1;
         if (predDefSurface == ESURFACE_SLM)
         {
             IGC_ASSERT(numElement <= 4);
@@ -11267,7 +11267,7 @@ void EmitPass::emitInsert(llvm::Instruct
             pVecVar = GetSymbol(pVec);
             if (pVecVar != pInstVar)
             {
-                emitVectorCopy(pInstVar, pVecVar, int_cast<unsigned>(dyn_cast<VectorType>(pVecType)->getNumElements()));
+                emitVectorCopy(pInstVar, pVecVar, int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(pVecType)->getNumElements()));
             }
         }
     }
@@ -15214,7 +15214,7 @@ bool EmitPass::isUniformStoreOCL(Value*
     }
 
     Type* Ty = storeVal->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     uint32_t elts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
     Type* eltTy = VTy ? VTy->getElementType() : Ty;
 
@@ -15250,7 +15250,7 @@ void EmitPass::emitVectorBitCast(llvm::B
     if (srcTy->isVectorTy())
     {
         srcEltTy = cast<VectorType>(srcTy)->getElementType();
-        srcNElts = (uint32_t)cast<VectorType>(srcTy)->getNumElements();
+        srcNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(srcTy)->getNumElements();
     }
     else
     {
@@ -15260,7 +15260,7 @@ void EmitPass::emitVectorBitCast(llvm::B
     if (dstTy->isVectorTy())
     {
         dstEltTy = cast<VectorType>(dstTy)->getElementType();
-        dstNElts = (uint32_t)cast<VectorType>(dstTy)->getNumElements();
+        dstNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(dstTy)->getNumElements();
     }
     else
     {
@@ -15848,7 +15848,7 @@ void EmitPass::emitVectorLoad(LoadInst*
     }
 
     Type* Ty = inst->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     Type* eltTy = VTy ? VTy->getElementType() : Ty;
     uint32_t eltBytes = GetScalarTypeSizeInRegister(eltTy);
     IGC_ASSERT_MESSAGE((eltBytes == 1) || (eltBytes == 2) || (eltBytes == 4) || (eltBytes == 8),
@@ -16362,7 +16362,7 @@ void EmitPass::emitVectorStore(StoreInst
 
     Value* storedVal = inst->getValueOperand();
     Type* Ty = storedVal->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     Type* eltTy = VTy ? VTy->getElementType() : Ty;
     uint32_t eltBytes = GetScalarTypeSizeInRegister(eltTy);
 
@@ -17170,7 +17170,7 @@ void EmitPass::emitCopyAll(CVariable* Ds
     }
     else if (Ty->isVectorTy())
     {
-        unsigned NElts = (unsigned)cast<VectorType>(Ty)->getNumElements();
+        unsigned NElts = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
         emitVectorCopy(Dst, Src, NElts);
     }
     else if (Ty->isStructTy())
@@ -18328,9 +18328,9 @@ void EmitPass::emitfcvt(llvm::GenIntrins
     CVariable* dst = m_destination;
 
     Type* dTy = GII->getType();
-    VectorType* dVTy = dyn_cast<VectorType>(dTy);
+    IGCLLVM::FixedVectorType* dVTy = dyn_cast<IGCLLVM::FixedVectorType>(dTy);
     Type* sTy = sVal->getType();
-    VectorType* sVTy = dyn_cast<VectorType>(sTy);
+    IGCLLVM::FixedVectorType* sVTy = dyn_cast<IGCLLVM::FixedVectorType>(sTy);
     int nelts = dVTy ? (int)dVTy->getNumElements() : 1;
     int src_nelts = sVTy ? (int)sVTy->getNumElements() : 1;
     if (nelts != src_nelts)
--- a/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
+++ b/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
@@ -1945,7 +1945,7 @@ bool InstExpander::visitExtractElement(E
     // later.
 
     Value* V = EEI.getVectorOperand();
-    unsigned NumElts = (unsigned)cast<VectorType>(V->getType())->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(V->getType())->getNumElements();
     V = IRB->CreateBitCast(V, Emu->getV2Int32Ty(NumElts));
     // Re-calculate indices to Lo and Hi parts.
     Value* Idx = EEI.getIndexOperand();
@@ -1982,7 +1982,7 @@ bool InstExpander::visitInsertElement(In
 
     // Create the emulated vector.
     Value* NewVal = IEI.getOperand(0);
-    unsigned NumElts = (unsigned)cast<VectorType>(NewVal->getType())->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(NewVal->getType())->getNumElements();
     NewVal = IRB->CreateBitCast(NewVal, Emu->getV2Int32Ty(NumElts));
     // Re-calculate indices to Lo and Hi parts.
     Value* Idx = IEI.getOperand(2);
--- a/IGC/Compiler/CISACodeGen/GenIRLowering.cpp
+++ b/IGC/Compiler/CISACodeGen/GenIRLowering.cpp
@@ -437,7 +437,7 @@ Value* GEPLowering::getSExtOrTrunc(Value
 
     IGC_ASSERT_MESSAGE(OldTy->isIntOrIntVectorTy(), "Index should be Integer or vector of Integer!");
 
-    if (auto OldVecTy = dyn_cast<VectorType>(OldTy)) {
+    if (auto OldVecTy = dyn_cast<IGCLLVM::FixedVectorType>(OldTy)) {
         OldWidth = (unsigned)OldVecTy->getNumElements() * OldVecTy->getElementType()->getIntegerBitWidth();
         NewWidth = (unsigned)OldVecTy->getNumElements() * NewTy->getIntegerBitWidth();
     }
@@ -789,7 +789,7 @@ bool GEPLowering::lowerGetElementPtrInst
                 }
                 else
                 {
-                    if (auto NewIdxVT = dyn_cast<VectorType>(NewIdx->getType())) {
+                    if (auto NewIdxVT = dyn_cast<IGCLLVM::FixedVectorType>(NewIdx->getType())) {
                         Value* result = llvm::UndefValue::get(FixedVectorType::get(PtrMathTy, (unsigned)NewIdxVT->getNumElements()));
                         for (uint32_t j = 0; j < (uint32_t)NewIdxVT->getNumElements(); j++) {
                             result = Builder->CreateInsertElement(result, PointerValue, Builder->getInt32(j));
--- a/IGC/Compiler/CISACodeGen/GenSimplification.cpp
+++ b/IGC/Compiler/CISACodeGen/GenSimplification.cpp
@@ -19,6 +19,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/InstVisitor.h>
 #include <llvm/IR/Instruction.h>
 #include <llvm/Support/raw_ostream.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Probe/Assertion.h"
 
@@ -148,7 +149,7 @@ bool GenSimplification::simplifyVectorPH
 
     Type* Ty = PN.getType();
     Type* EltTy = Ty->getScalarType();
-    unsigned NumElts = (unsigned)cast<VectorType>(Ty)->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
 
     SmallVector<Value*, 8> Lanes;
     SmallVector<SmallVector<Value*, 8>, 4> Values;
@@ -222,7 +223,7 @@ void GenSimplification::visitPHINode(PHI
 void GenSimplification::visitExtractElement(ExtractElementInst& EEI) {
     // Skip non-2-element vector.
     Value* Vec = EEI.getVectorOperand();
-    VectorType* VTy = cast<VectorType>(Vec->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(Vec->getType());
     if (VTy->getNumElements() != 2)
         return;
 
--- a/IGC/Compiler/CISACodeGen/GeometryShaderLowering.cpp
+++ b/IGC/Compiler/CISACodeGen/GeometryShaderLowering.cpp
@@ -17,6 +17,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/PassManager.h>
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/IR/Verifier.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/InitializePasses.h"
 #include "Probe/Assertion.h"
@@ -444,7 +445,7 @@ void GeometryShaderLowering::AddURBRead(
     {
         Value* vec = UndefValue::get(inst->getType());
         IRBuilder<> builder(inst);
-        for (unsigned int i = 0; i < cast<VectorType>(inst->getType())->getNumElements(); i++)
+        for (unsigned int i = 0; i < cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements(); i++)
         {
             Value* vecElement = builder.CreateExtractElement(urbRead, builder.getInt32(i));
             vec = builder.CreateInsertElement(vec, vecElement, builder.getInt32(i));
--- a/IGC/Compiler/CISACodeGen/LdShrink.cpp
+++ b/IGC/Compiler/CISACodeGen/LdShrink.cpp
@@ -14,6 +14,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/MathExtras.h>
 #include <llvm/Support/raw_ostream.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/CISACodeGen/ShaderCodeGen.hpp"
 #include "Compiler/IGCPassSupport.h"
@@ -63,7 +64,7 @@ IGC_INITIALIZE_PASS_BEGIN(LdShrink, PASS
 IGC_INITIALIZE_PASS_END(LdShrink, PASS_FLAG, PASS_DESC, PASS_CFG_ONLY, PASS_ANALYSIS)
 
 unsigned LdShrink::getExtractIndexMask(LoadInst* LI) const {
-    VectorType* VTy = dyn_cast<VectorType>(LI->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(LI->getType());
     // Skip non-vector loads.
     if (!VTy)
         return 0;
@@ -75,9 +76,12 @@ unsigned LdShrink::getExtractIndexMask(L
     Type* Ty = VTy->getScalarType();
     // Skip non-BYTE addressable data types. So far, check integer types
     // only.
-    if (IntegerType * ITy = dyn_cast<IntegerType>(Ty))
-        if (!ITy->isPowerOf2ByteWidth())
+    if (IntegerType * ITy = dyn_cast<IntegerType>(Ty)) {
+        // Unroll isPowerOf2ByteWidth, it was removed in LLVM 12.
+        unsigned BitWidth = ITy->getBitWidth();
+        if (!((BitWidth > 7) && isPowerOf2_32(BitWidth)))
             return 0;
+    }
 
     unsigned Mask = 0; // Maxmimally 32 elements.
 
--- a/IGC/Compiler/CISACodeGen/LowerGEPForPrivMem.cpp
+++ b/IGC/Compiler/CISACodeGen/LowerGEPForPrivMem.cpp
@@ -603,7 +603,7 @@ void TransposeHelper::handleGEPInst(
             }
             else
             {
-                arr_sz = (unsigned)cast<VectorType>(T)->getNumElements();
+                arr_sz = (unsigned)cast<IGCLLVM::FixedVectorType>(T)->getNumElements();
             }
             T = cast<VectorType>(T)->getElementType();
         }
@@ -625,7 +625,7 @@ void TransposeHelper::handleGEPInst(
         }
         else if (T->isVectorTy())
         {
-            arr_sz = (unsigned)cast<VectorType>(T)->getNumElements();
+            arr_sz = (unsigned)cast<IGCLLVM::FixedVectorType>(T)->getNumElements();
             T = cast<VectorType>(T)->getElementType();
         }
         else
@@ -685,7 +685,7 @@ void TransposeHelperPromote::handleLoadI
     IRBuilder<> IRB(pLoad);
     IGC_ASSERT(nullptr != pLoad->getType());
     unsigned N = pLoad->getType()->isVectorTy()
-        ? (unsigned)cast<VectorType>(pLoad->getType())->getNumElements()
+        ? (unsigned)cast<IGCLLVM::FixedVectorType>(pLoad->getType())->getNumElements()
         : 1;
     Value* Val = loadEltsFromVecAlloca(N, pVecAlloca, pScalarizedIdx, IRB, pLoad->getType()->getScalarType());
     pLoad->replaceAllUsesWith(Val);
@@ -717,7 +717,7 @@ void TransposeHelperPromote::handleStore
         // %v1 = extractelement <2 x float> %v, i32 1
         // %w1 = insertelement <32 x float> %w0, float %v1, i32 %idx+1
         // store <32 x float> %w1, <32 x float>* %ptr1
-        for (unsigned i = 0, e = (unsigned)cast<VectorType>(pStoreVal->getType())->getNumElements(); i < e; ++i)
+        for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(pStoreVal->getType())->getNumElements(); i < e; ++i)
         {
             Value* VectorIdx = ConstantInt::get(pScalarizedIdx->getType(), i);
             auto Val = IRB.CreateExtractElement(pStoreVal, VectorIdx);
--- a/IGC/Compiler/CISACodeGen/MemOpt.cpp
+++ b/IGC/Compiler/CISACodeGen/MemOpt.cpp
@@ -108,7 +108,7 @@ namespace {
             MemRefListTy& MemRefs, TrivialMemRefListTy& ToOpt);
 
         unsigned getNumElements(Type* Ty) const {
-            return Ty->isVectorTy() ? (unsigned)cast<VectorType>(Ty)->getNumElements() : 1;
+            return Ty->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements() : 1;
         }
 
         MemoryLocation getLocation(Instruction* I) const {
@@ -922,7 +922,7 @@ bool MemOpt::mergeLoad(LoadInst* Leading
             Pos = unsigned((std::get<1>(I) - FirstOffset) / LdScalarSize);
 
         if (Ty->isVectorTy()) {
-            if (Pos + cast<VectorType>(Ty)->getNumElements() > NumElts) {
+            if (Pos + cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements() > NumElts) {
                 // This implies we're trying to extract an element from our new load
                 // with an index > the size of the new load.  If this happens,
                 // we'll generate correct code if it does since we don't remove the
@@ -930,7 +930,7 @@ bool MemOpt::mergeLoad(LoadInst* Leading
                 continue;
             }
             Value* Val = UndefValue::get(Ty);
-            for (unsigned i = 0, e = (unsigned)cast<VectorType>(Ty)->getNumElements(); i != e; ++i) {
+            for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements(); i != e; ++i) {
                 Value* Ex = Builder.CreateExtractElement(NewLoad, Builder.getInt32(Pos + i));
                 Ex = createBitOrPointerCast(Ex, ScalarTy, Builder);
                 Val = Builder.CreateInsertElement(Val, Ex, Builder.getInt32(i));
@@ -1312,7 +1312,7 @@ bool MemOpt::mergeStore(StoreInst* Leadi
         IGC_ASSERT(hasSameSize(ScalarTy, LeadingStoreScalarType));
 
         if (Ty->isVectorTy()) {
-            for (unsigned i = 0, e = (unsigned)cast<VectorType>(Ty)->getNumElements(); i != e; ++i) {
+            for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements(); i != e; ++i) {
                 Value* Ex = Builder.CreateExtractElement(Val, Builder.getInt32(i));
                 Ex = createBitOrPointerCast(Ex, LeadingStoreScalarType, Builder);
                 NewStoreVal = Builder.CreateInsertElement(NewStoreVal, Ex,
--- a/IGC/Compiler/CISACodeGen/MemOpt2.cpp
+++ b/IGC/Compiler/CISACodeGen/MemOpt2.cpp
@@ -16,6 +16,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/raw_ostream.h>
 #include <llvm/Transforms/Utils/Local.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 
@@ -108,7 +109,7 @@ namespace {
             if (!Ty->isSingleValueType())
                 return UINT_MAX;
             // Simply return 1 so far for scalar types.
-            VectorType* VecTy = dyn_cast<VectorType>(Ty);
+            IGCLLVM::FixedVectorType* VecTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
             if (!VecTy)
                 return 1;
             // Check how that vector is used.
@@ -137,7 +138,7 @@ namespace {
                 return UINT_MAX;
             unsigned EltByte = (Ty->getScalarSizeInBits() + 7) / 8;
             // Simply return 1 so far for scalar types.
-            VectorType* VecTy = dyn_cast<VectorType>(Ty);
+            IGCLLVM::FixedVectorType* VecTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
             if (!VecTy)
                 return EltByte;
             // Check how that vector is used.
--- a/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
@@ -409,7 +409,7 @@ namespace IGC
         unsigned int numElements = 1;
         if (baseType->isVectorTy())
         {
-            numElements = (unsigned)cast<VectorType>(baseType)->getNumElements();
+            numElements = (unsigned)cast<IGCLLVM::FixedVectorType>(baseType)->getNumElements();
             baseType = cast<VectorType>(baseType)->getElementType();
         }
 
--- a/IGC/Compiler/CISACodeGen/PatternMatchPass.cpp
+++ b/IGC/Compiler/CISACodeGen/PatternMatchPass.cpp
@@ -2438,7 +2438,7 @@ namespace IGC
         // Store3d supports only types equal or less than 128 bits.
         if (auto* storeInst = dyn_cast<StoreInst>(&I))
         {
-            llvm::VectorType* vectorToStore = dyn_cast<llvm::VectorType>(storeInst->getValueOperand()->getType());
+            IGCLLVM::FixedVectorType* vectorToStore = dyn_cast<IGCLLVM::FixedVectorType>(storeInst->getValueOperand()->getType());
 
             // If stored value is a vector of pointers, the size must be calculated manually,
             // because getPrimitiveSizeInBits returns 0 for pointers.
@@ -3072,8 +3072,8 @@ namespace IGC
                 llvm::Type* srcTy = bTInst->getOperand(0)->getType();
                 llvm::Type* dstTy = bTInst->getType();
 
-                srcNElts = (srcTy->isVectorTy()) ? (uint32_t)cast<VectorType>(srcTy)->getNumElements() : 1;
-                dstNElts = (dstTy->isVectorTy()) ? (uint32_t)cast<VectorType>(dstTy)->getNumElements() : 1;
+                srcNElts = (srcTy->isVectorTy()) ? (uint32_t)cast<IGCLLVM::FixedVectorType>(srcTy)->getNumElements() : 1;
+                dstNElts = (dstTy->isVectorTy()) ? (uint32_t)cast<IGCLLVM::FixedVectorType>(dstTy)->getNumElements() : 1;
 
                 if (srcNElts < dstNElts && srcTy->getScalarSizeInBits() < 64)
                 {
--- a/IGC/Compiler/CISACodeGen/PushAnalysis.cpp
+++ b/IGC/Compiler/CISACodeGen/PushAnalysis.cpp
@@ -987,7 +987,7 @@ namespace IGC
 
         if (pTypeToPush->isVectorTy())
         {
-            num_elms = (unsigned)cast<VectorType>(pTypeToPush)->getNumElements();
+            num_elms = (unsigned)cast<IGCLLVM::FixedVectorType>(pTypeToPush)->getNumElements();
             pTypeToPush = cast<VectorType>(pTypeToPush)->getElementType();
             llvm::Type* pVecTy = IGCLLVM::FixedVectorType::get(pTypeToPush, num_elms);
             pReplacedInst = llvm::UndefValue::get(pVecTy);
@@ -1178,7 +1178,7 @@ namespace IGC
         }
 
         unsigned num_elms =
-            inst->getType()->isVectorTy() ? (unsigned)cast<VectorType>(inst->getType())->getNumElements() : 1;
+            inst->getType()->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements() : 1;
         llvm::Type* pTypeToPush = inst->getType();
         llvm::Value* replaceVector = nullptr;
         unsigned int numberChannelReplaced = 0;
--- a/IGC/Compiler/CISACodeGen/RegisterEstimator.cpp
+++ b/IGC/Compiler/CISACodeGen/RegisterEstimator.cpp
@@ -25,6 +25,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/IR/InstIterator.h>
 #include <llvm/Support/MathExtras.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Probe/Assertion.h"
 
@@ -130,7 +131,7 @@ RegUse RegisterEstimator::estimateNumOfR
     Type* Ty = V->getType();
     if (!Ty->isVoidTy())
     {
-        VectorType* VTy = dyn_cast<VectorType>(Ty);
+        IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
         Type* eltTy = VTy ? VTy->getElementType() : Ty;
         uint32_t nelts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
         uint32_t eltBits = (uint32_t)m_DL->getTypeSizeInBits(eltTy);
--- a/IGC/Compiler/CISACodeGen/RegisterPressureEstimate.hpp
+++ b/IGC/Compiler/CISACodeGen/RegisterPressureEstimate.hpp
@@ -24,6 +24,7 @@ See LICENSE.TXT for details.
 #include "llvm/Pass.h"
 #include <llvm/IR/InstVisitor.h>
 #include "llvm/Analysis/LoopInfo.h"
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/IGCPassSupport.h"
 #include "Compiler/CISACodeGen/WIAnalysis.hpp"
@@ -222,7 +223,7 @@ namespace IGC
             auto Ty = V->getType();
             if (Ty->isVoidTy())
                 return 0;
-            auto VTy = llvm::dyn_cast<llvm::VectorType>(Ty);
+            auto VTy = llvm::dyn_cast<IGCLLVM::FixedVectorType>(Ty);
             auto eltTy = VTy ? VTy->getElementType() : Ty;
             uint32_t nelts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
             uint32_t eltBits = (uint32_t)m_DL->getTypeSizeInBits(eltTy);
--- a/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
+++ b/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
@@ -23,6 +23,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/InstIterator.h>
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/MathExtras.h>
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPop.hpp"
 #include <vector>
 #include "Probe/Assertion.h"
@@ -613,7 +614,7 @@ bool SLMConstProp::isEqual(Constant* C0,
 
 bool SLMConstProp::isFloatType(Type* Ty)
 {
-    if (VectorType * vTy = dyn_cast<VectorType>(Ty))
+    if (IGCLLVM::FixedVectorType * vTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty))
     {
         if (vTy->getNumElements() > 1)
         {
--- a/IGC/Compiler/CISACodeGen/ScalarizerCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/ScalarizerCodeGen.cpp
@@ -50,7 +50,7 @@ void ScalarizerCodeGen::visitBinaryOpera
         {
             bool isNewTypeVector = false;
 
-            VectorType* instType = cast<VectorType>(I.getType());
+            IGCLLVM::FixedVectorType* instType = cast<IGCLLVM::FixedVectorType>(I.getType());
             unsigned numElements = int_cast<unsigned>(instType->getNumElements());
             unsigned scalarSize = instType->getScalarSizeInBits();
             unsigned newScalarBits = numElements * scalarSize;
@@ -95,7 +95,7 @@ void ScalarizerCodeGen::visitBinaryOpera
                 }
                 else
                 {
-                    VectorType* newVecType = cast<VectorType>(newType);
+                    IGCLLVM::FixedVectorType* newVecType = cast<IGCLLVM::FixedVectorType>(newType);
                     unsigned newVecTypeNumEle = int_cast<unsigned>(newVecType->getNumElements());
                     Value* ieLogicOp = UndefValue::get(newType);
                     for (unsigned i = 0; i < newVecTypeNumEle; i++)
--- a/IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp
@@ -637,12 +637,17 @@ static void AddLegalizationPasses(CodeGe
     {
         mpm.add(createPruneUnusedArgumentsPass());
 
+#if LLVM_VERSION_MAJOR >= 12
+        mpm.add(createIPSCCPPass());
+#else
         if (IGC_GET_FLAG_VALUE(FunctionControl) == FLAG_FCALL_DEFAULT)
         {
             // Don't run IPConstantProp when debugging function calls, to avoid folding function arg/ret constants
             mpm.add(createIPConstantPropagationPass());
         }
         mpm.add(createConstantPropagationPass());
+#endif
+
         mpm.add(createDeadCodeEliminationPass());
         mpm.add(createCFGSimplificationPass());
     }
@@ -1547,8 +1552,13 @@ void OptimizeIR(CodeGenContext* const pC
             // possible which potentially allows late stage code sinking of
             // those calls by the instruction combiner.
             mpm.add(createPostOrderFunctionAttrsLegacyPass());
+
+#if LLVM_VERSION_MAJOR >= 12
+            mpm.add(createIPSCCPPass());
+#else
             mpm.add(createConstantPropagationPass());
             mpm.add(createIPConstantPropagationPass());
+#endif
         }
 
         // enable this only when Pooled EU is not supported
--- a/IGC/Compiler/CISACodeGen/Simd32Profitability.cpp
+++ b/IGC/Compiler/CISACodeGen/Simd32Profitability.cpp
@@ -12,8 +12,10 @@ SPDX-License-Identifier: MIT
 #include "Compiler/CISACodeGen/Platform.hpp"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvmWrapper/IR/DerivedTypes.h>
+#include <llvmWrapper/Transforms/Utils/LoopUtils.h>
 #include <llvm/IR/InstIterator.h>
 #include <llvm/IR/Operator.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 #include "GenISAIntrinsics/GenIntrinsicInst.h"
@@ -561,7 +563,7 @@ static bool isPayloadHeader(Value* V) {
     Argument* Arg = dyn_cast<Argument>(V);
     if (!Arg || !Arg->hasName())
         return false;
-    VectorType* VTy = dyn_cast<VectorType>(Arg->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Arg->getType());
     if (!VTy || VTy->getNumElements() != 8 ||
         !VTy->getElementType()->isIntegerTy(32))
         return false;
@@ -572,7 +574,7 @@ static bool isR0(Value* V) {
     Argument* Arg = dyn_cast<Argument>(V);
     if (!Arg || !Arg->hasName())
         return false;
-    VectorType* VTy = dyn_cast<VectorType>(Arg->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Arg->getType());
     if (!VTy || VTy->getNumElements() != 8 ||
         !VTy->getElementType()->isIntegerTy(32))
         return false;
@@ -583,7 +585,7 @@ static bool isEnqueuedLocalSize(Value* V
     Argument* Arg = dyn_cast<Argument>(V);
     if (!Arg || !Arg->hasName())
         return false;
-    VectorType* VTy = dyn_cast<VectorType>(Arg->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Arg->getType());
     if (!VTy || VTy->getNumElements() != 3 ||
         !VTy->getElementType()->isIntegerTy(32))
         return false;
@@ -982,7 +984,7 @@ static bool hasLongStridedLdStInLoop(Fun
     // Collect innermost simple loop.
     for (auto I = LI->begin(), E = LI->end(); I != E; ++I) {
         auto L = *I;
-        if (!L->empty())
+        if (!IGCLLVM::isInnermost(L))
             continue;
         if (L->getNumBlocks() != 2)
             continue;
--- a/IGC/Compiler/CISACodeGen/SimplifyConstant.cpp
+++ b/IGC/Compiler/CISACodeGen/SimplifyConstant.cpp
@@ -336,7 +336,7 @@ static unsigned getLegalVectorSize(unsig
 // Check vector size. We may demote the data type if all values can fit into
 // smaller data type.
 //
-static bool checkSize(GlobalVariable* GV, VectorType*& DataType,
+static bool checkSize(GlobalVariable* GV, IGCLLVM::FixedVectorType*& DataType,
     bool& IsSigned) {
     Constant* Init = GV->getInitializer();
     IGC_ASSERT(isa<ArrayType>(Init->getType()));
@@ -344,7 +344,7 @@ static bool checkSize(GlobalVariable* GV
     unsigned N = (unsigned)ArrayTy->getArrayNumElements();
     Type* BaseTy = ArrayTy->getArrayElementType();
     unsigned VectorSize = 1;
-    if (auto VT = dyn_cast<VectorType>(BaseTy)) {
+    if (auto VT = dyn_cast<IGCLLVM::FixedVectorType>(BaseTy)) {
         BaseTy = VT->getElementType();
         VectorSize = int_cast<unsigned>(VT->getNumElements());
         N *= VectorSize;
@@ -467,7 +467,7 @@ static Constant* getConstantVal(Type* VE
     return ConstantInt::get(VEltTy, IVal, IsSigned);
 }
 
-static void promote(GlobalVariable* GV, VectorType* AllocaType, bool IsSigned,
+static void promote(GlobalVariable* GV, IGCLLVM::FixedVectorType* AllocaType, bool IsSigned,
     Function* F) {
     // Build the constant vector from constant array.
     unsigned VS = int_cast<unsigned>(AllocaType->getNumElements());
@@ -491,7 +491,7 @@ static void promote(GlobalVariable* GV,
             Constant* const Elt = CA->getAggregateElement(i);
             IGC_ASSERT_MESSAGE(nullptr != Elt, "Null AggregateElement");
             if (auto EltTy = dyn_cast<VectorType>(Elt->getType())) {
-                unsigned VectorSize = (unsigned)cast<VectorType>(EltTy)->getNumElements();
+                unsigned VectorSize = (unsigned)cast<IGCLLVM::FixedVectorType>(EltTy)->getNumElements();
                 for (unsigned j = 0; j < VectorSize; ++j) {
                     Constant* V = Elt->getAggregateElement(j);
                     Vals[i * VectorSize + j] = getConstantVal(VEltTy, V, IsSigned);
@@ -533,7 +533,7 @@ static void promote(GlobalVariable* GV,
             unsigned N = 1;
             Value* Offset = Index;
             if (Ty->isVectorTy()) {
-                N = (unsigned)cast<VectorType>(Ty)->getNumElements();
+                N = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
                 Offset = Builder.CreateMul(Offset, ConstantInt::get(Offset->getType(), N));
             }
             Value* Val = extractNElts(N, VectorData, Offset, Builder);
@@ -668,7 +668,7 @@ bool PromoteConstant::runOnFunction(Func
 
         // If possible demote the data into smaller type. Uses of value will be
         // promoted back with ZExt or SExt.
-        VectorType* AllocaType = nullptr;
+        IGCLLVM::FixedVectorType* AllocaType = nullptr;
         bool IsSigned = false;
         if (!checkSize(GV, AllocaType, IsSigned))
             continue;
--- a/IGC/Compiler/CISACodeGen/TypeDemote.cpp
+++ b/IGC/Compiler/CISACodeGen/TypeDemote.cpp
@@ -16,6 +16,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/ADT/PostOrderIterator.h>
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/Pass.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 #include "Probe/Assertion.h"
@@ -272,7 +273,7 @@ bool TypeDemote::demoteOnBasicBlock(Basi
             CastInst* CI = dyn_cast<CastInst>(Index);
             if (CI && (CI->getOpcode() == Instruction::ZExt ||
                 CI->getOpcode() == Instruction::SExt)) {
-                unsigned VS = (unsigned)cast<VectorType>(EEI->getVectorOperandType())->getNumElements();
+                unsigned VS = (unsigned)cast<IGCLLVM::FixedVectorType>(EEI->getVectorOperandType())->getNumElements();
                 unsigned N = (unsigned int)CI->getSrcTy()->getPrimitiveSizeInBits();
                 unsigned Bound = (N < 32) ? (1U << N) : UINT32_MAX;
                 if (VS <= Bound) {
--- a/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.cpp
+++ b/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.cpp
@@ -12,6 +12,7 @@ SPDX-License-Identifier: MIT
 #include "Compiler/CodeGenPublic.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/Support/Debug.h>
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPop.hpp"
 #include <algorithm>
 #include "Probe/Assertion.h"
@@ -24,13 +25,13 @@ namespace
     // If V is scalar, return 1.
     // if V is vector, return the number of elements.
     inline int getNumElts(Value* V) {
-        VectorType* VTy = dyn_cast<VectorType>(V->getType());
+        IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(V->getType());
         return VTy ? (int)VTy->getNumElements() : 1;
     }
 
     inline int getTypeSizeInBits(Type* Ty) {
         int scalarBits = Ty->getScalarSizeInBits();
-        VectorType* VTy = dyn_cast<VectorType>(Ty);
+        IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
         return scalarBits * (VTy ? (int)VTy->getNumElements() : 1);
     }
 }
--- a/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.hpp
+++ b/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.hpp
@@ -21,6 +21,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/InstIterator.h>
 #include <llvm/IR/InstVisitor.h>
 #include "llvm/Pass.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/Support/raw_ostream.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/CISACodeGen/RegisterEstimator.hpp"
@@ -63,7 +64,7 @@ namespace IGC {
         SSubVecDesc(llvm::Value* V)
             : Aliaser(V), BaseVector(V), StartElementOffset(0)
         {
-            llvm::VectorType* VTy = llvm::dyn_cast<llvm::VectorType>(V->getType());
+            IGCLLVM::FixedVectorType* VTy = llvm::dyn_cast<IGCLLVM::FixedVectorType>(V->getType());
             NumElts = VTy ? (short)VTy->getNumElements() : 1;
         }
 
--- a/IGC/Compiler/CISACodeGen/VectorPreProcess.cpp
+++ b/IGC/Compiler/CISACodeGen/VectorPreProcess.cpp
@@ -485,7 +485,7 @@ void VectorPreProcess::replaceAllVectorU
             I = VI->getParent()->getFirstNonPHI();
         }
         IRBuilder<> Builder(I);
-        VectorType* VTy = cast<VectorType>(VI->getType());
+        IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(VI->getType());
         Value* newVec = UndefValue::get(VTy);
         for (uint32_t i = 0, e = int_cast<uint32_t>(VTy->getNumElements()); i < e; ++i)
         {
@@ -626,7 +626,7 @@ bool VectorPreProcess::splitStore(
 {
     Instruction* SI = ASI.getInst();
     Value* StoredVal = ASI.getValueOperand();
-    VectorType* VTy = cast<VectorType>(StoredVal->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(StoredVal->getType());
     Type* ETy = VTy->getElementType();
     uint32_t nelts = int_cast<uint32_t>(VTy->getNumElements());
 
@@ -712,7 +712,7 @@ bool VectorPreProcess::splitStore(
         {
             Type* Ty1 = splitInfo[i].first;
             uint32_t len1 = splitInfo[i].second;
-            VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+            IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
             for (uint32_t j = 0; j < len1; ++j)
             {
                 Value* subVec;
@@ -749,7 +749,7 @@ bool VectorPreProcess::splitStore(
     {
         Type* Ty1 = splitInfo[i].first;
         uint32_t len1 = splitInfo[i].second;
-        VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+        IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
         for (uint32_t j = 0; j < len1; ++j)
         {
             uint32_t vAlign = (uint32_t)MinAlign(Align, (uint32_t)eOffset * EBytes);
@@ -793,7 +793,7 @@ bool VectorPreProcess::splitLoad(
 {
     Instruction* LI = ALI.getInst();
     bool isLdRaw = isa<LdRawIntrinsic>(LI);
-    VectorType* VTy = cast<VectorType>(LI->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(LI->getType());
     Type* ETy = VTy->getElementType();
     uint32_t nelts = int_cast<uint32_t>(VTy->getNumElements());
 
@@ -855,7 +855,7 @@ bool VectorPreProcess::splitLoad(
     {
         Type* Ty1 = splitInfo[i].first;
         uint32_t len1 = splitInfo[i].second;
-        VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+        IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
         for (uint32_t j = 0; j < len1; ++j)
         {
             uint32_t vAlign = (uint32_t)MinAlign(Align, eOffset * EBytes);
@@ -923,7 +923,7 @@ bool VectorPreProcess::splitLoadStore(
     Optional<AbstractStoreInst> ASI = AbstractStoreInst::get(Inst);
     IGC_ASSERT_MESSAGE((ALI || ASI), "Inst should be either load or store");
     Type* Ty = ALI ? ALI->getInst()->getType() : ASI->getValueOperand()->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     if (!VTy)
     {
         return false;
@@ -1154,7 +1154,7 @@ void VectorPreProcess::getOrGenScalarVal
 {
     availBeforeInst = nullptr;
 
-    VectorType* VTy = cast<VectorType>(VecVal->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(VecVal->getType());
     if (!VTy)
     {
         scalars[0] = VecVal;
@@ -1305,7 +1305,7 @@ Instruction* VectorPreProcess::simplifyL
         //
         // TODO: further optimize this load into a message with channel masks
         // for cases in which use indices are sparse like {0, 2}.
-        unsigned N = (unsigned)cast<VectorType>(Inst->getType())->getNumElements();
+        unsigned N = (unsigned)cast<IGCLLVM::FixedVectorType>(Inst->getType())->getNumElements();
         if (N == MaxIndex + 1)
             return Inst;
 
@@ -1420,7 +1420,7 @@ Instruction* VectorPreProcess::simplifyL
     if (NBits < 32)
         return Inst;
 
-    unsigned N = (unsigned)cast<VectorType>(Val->getType())->getNumElements();
+    unsigned N = (unsigned)cast<IGCLLVM::FixedVectorType>(Val->getType())->getNumElements();
     if (auto CV = dyn_cast<ConstantVector>(Val))
     {
         unsigned MaxIndex = 0;
@@ -1589,7 +1589,7 @@ bool VectorPreProcess::runOnFunction(Fun
                 for (uint32_t j = 0; j < svals.size(); ++j)
                 {
                     Type* Ty1 = svals[j]->getType();
-                    VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+                    IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
                     if (VTy1) {
                         for (uint32_t k = 0; k < VTy1->getNumElements(); ++k)
                         {
@@ -1638,7 +1638,7 @@ bool VectorPreProcess::runOnFunction(Fun
                     // If this is a 3-element vector load, remove it
                     // from m_Vector3List as well.
                     if (isAbstractLoadInst(tInst) && tInst->getType()->isVectorTy() &&
-                        cast<VectorType>(tInst->getType())->getNumElements() == 3)
+                        cast<IGCLLVM::FixedVectorType>(tInst->getType())->getNumElements() == 3)
                     {
                         InstWorkVector::iterator
                             tI = m_Vector3List.begin(),
--- a/IGC/Compiler/CISACodeGen/VectorProcess.cpp
+++ b/IGC/Compiler/CISACodeGen/VectorProcess.cpp
@@ -224,7 +224,7 @@ bool VectorProcess::reLayoutLoadStore(In
     IGC_ASSERT(nullptr != Ptr);
     IGC_ASSERT(nullptr != Ty);
 
-    VectorType* const VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* const VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
 
     // Treat a scalar as 1-element vector
     uint32_t nelts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
@@ -638,7 +638,7 @@ void VectorMessage::getInfo(Type* Ty, ui
     VectorType* VTy = dyn_cast<VectorType>(Ty);
     Type* eTy = VTy ? cast<VectorType>(VTy)->getElementType() : Ty;
     unsigned eltSize = m_emitter->GetScalarTypeSizeInRegister(eTy);
-    unsigned nElts = VTy ? (unsigned)cast<VectorType>(VTy)->getNumElements() : 1;
+    unsigned nElts = VTy ? (unsigned)cast<IGCLLVM::FixedVectorType>(VTy)->getNumElements() : 1;
     // total bytes
     const unsigned TBytes = nElts * eltSize;
 
--- a/IGC/Compiler/CISACodeGen/helper.cpp
+++ b/IGC/Compiler/CISACodeGen/helper.cpp
@@ -1745,7 +1745,7 @@ namespace IGC
             {
                 instList[i] = builder.CreateExtractElement(val, static_cast<uint64_t>(0));
                 size_t iOld = i;
-                for (unsigned j = 1; j < cast<VectorType>(val->getType())->getNumElements(); j++)
+                for (unsigned j = 1; j < cast<IGCLLVM::FixedVectorType>(val->getType())->getNumElements(); j++)
                 {
                     instList.insert(instList.begin()+ iOld +j, builder.CreateExtractElement(val, j));
                     i++;
@@ -1778,7 +1778,7 @@ namespace IGC
             }
             break;
         case IGCLLVM::VectorTyID:
-            num = (unsigned)cast<VectorType>(type)->getNumElements();
+            num = (unsigned)cast<IGCLLVM::FixedVectorType>(type)->getNumElements();
             for (unsigned i = 0; i < num; i++)
             {
                 ScalarizeAggregateMembers(builder, builder.CreateExtractElement(val, i), instList);
@@ -1818,7 +1818,7 @@ namespace IGC
             }
             break;
         case IGCLLVM::VectorTyID:
-            num = (unsigned)cast<VectorType>(type)->getNumElements();
+            num = (unsigned)cast<IGCLLVM::FixedVectorType>(type)->getNumElements();
             for (unsigned i = 0; i < num; i++)
             {
                 indices.push_back(builder.getInt32(i));
@@ -2083,8 +2083,8 @@ namespace IGC
                 return false;
             }
 
-            VectorType* dVTy = dyn_cast<VectorType>(dTy);
-            VectorType* sVTy = dyn_cast<VectorType>(sTy);
+            IGCLLVM::FixedVectorType* dVTy = dyn_cast<IGCLLVM::FixedVectorType>(dTy);
+            IGCLLVM::FixedVectorType* sVTy = dyn_cast<IGCLLVM::FixedVectorType>(sTy);
             int d_nelts = dVTy ? (int)dVTy->getNumElements() : 1;
             int s_nelts = sVTy ? (int)sVTy->getNumElements() : 1;
             if (d_nelts != s_nelts) {
--- a/IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp
+++ b/IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp
@@ -138,12 +138,12 @@ void ConvertMSAAPayloadTo16Bit::visitCal
             // There are uses of ldmcs other then ldms, using vector of int32 type.
             // Fix them to use newly created 16bit ldmcs.
             if (ldmcs->getType()->isVectorTy() &&
-                cast<VectorType>(ldmcs->getType())->getElementType() == m_builder->getInt32Ty())
+                cast<IGCLLVM::FixedVectorType>(ldmcs->getType())->getElementType() == m_builder->getInt32Ty())
             {
                 m_builder->SetInsertPoint(ldmcs);
 
-                uint32_t ldmcsNumOfElements =    (uint32_t)cast<VectorType>(ldmcs->getType())->getNumElements();
-                uint32_t newLdmcsNumOfElements = (uint32_t)cast<VectorType>(new_mcs_call->getType())->getNumElements();
+                uint32_t ldmcsNumOfElements =    (uint32_t)cast<IGCLLVM::FixedVectorType>(ldmcs->getType())->getNumElements();
+                uint32_t newLdmcsNumOfElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(new_mcs_call->getType())->getNumElements();
 
                 // vec of 16bit ints to vec of 32bit ints
                 Type* newLdmcsVecType = IGCLLVM::FixedVectorType::get(m_builder->getInt32Ty(), newLdmcsNumOfElements);
--- a/IGC/Compiler/CustomSafeOptPass.cpp
+++ b/IGC/Compiler/CustomSafeOptPass.cpp
@@ -1544,7 +1544,7 @@ void IGC::CustomSafeOptPass::visitSample
 bool CustomSafeOptPass::isIdentityMatrix(ExtractElementInst& I)
 {
     bool found = false;
-    auto extractType = cast<VectorType>(I.getVectorOperandType());
+    auto extractType = cast<IGCLLVM::FixedVectorType>(I.getVectorOperandType());
     auto extractTypeVecSize = (uint32_t)extractType->getNumElements();
     if (extractTypeVecSize == 20 ||
         extractTypeVecSize == 16)
@@ -1773,7 +1773,7 @@ void CustomSafeOptPass::visitExtractElem
                     int elOffset = (int)(bitShift / eltSize);
                     elOffset = rightShift ? elOffset : -elOffset;
                     unsigned int newIndex = (unsigned int)((int)cstIndex->getZExtValue() + elOffset);
-                    if (newIndex < cast<VectorType>(vecType)->getNumElements())
+                    if (newIndex < cast<IGCLLVM::FixedVectorType>(vecType)->getNumElements())
                     {
                         IRBuilder<> builder(&I);
                         Value* newBitCast = builder.CreateBitCast(binOp->getOperand(0), vecType);
@@ -2173,7 +2173,7 @@ void GenSpecificPattern::createBitcastEx
         else if (auto IEIInst = dyn_cast<InsertElementInst>(Op))
         {
             auto opType = IEIInst->getType();
-            if (opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<VectorType>(opType)->getNumElements() == 2)
+            if (opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<IGCLLVM::FixedVectorType>(opType)->getNumElements() == 2)
             {
                 elem = IEIInst->getOperand(1);
             }
@@ -2236,7 +2236,7 @@ void GenSpecificPattern::visitBinaryOper
         else if (match(&I, pattern2) && AndOp2->getType()->isIntegerTy(64))
         {
             ConstantVector* cVec = dyn_cast<ConstantVector>(VecOp);
-            VectorType* vector_type = dyn_cast<VectorType>(VecOp->getType());
+            IGCLLVM::FixedVectorType* vector_type = dyn_cast<IGCLLVM::FixedVectorType>(VecOp->getType());
             if (cVec && vector_type &&
                 isa<ConstantInt>(cVec->getOperand(0)) &&
                 cast<ConstantInt>(cVec->getOperand(0))->isZero() &&
@@ -2382,7 +2382,7 @@ void GenSpecificPattern::visitBinaryOper
             BitCastInst* opBC = cast<BitCastInst>(op);
 
             auto opType = opBC->getType();
-            if (!(opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<VectorType>(opType)->getNumElements() == 2))
+            if (!(opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<IGCLLVM::FixedVectorType>(opType)->getNumElements() == 2))
                 return nullptr;
 
             if (opBC->getSrcTy()->isDoubleTy())
@@ -2808,8 +2808,8 @@ void GenSpecificPattern::visitBitCastIns
                 if (zExtInst->getOperand(0)->getType()->isIntegerTy(32) &&
                     isa<InsertElementInst>(bitCastInst->getOperand(0)) &&
                     bitCastInst->getOperand(0)->getType()->isVectorTy() &&
-                    cast<VectorType>(bitCastInst->getOperand(0)->getType())->getElementType()->isIntegerTy(32) &&
-                    cast<VectorType>(bitCastInst->getOperand(0)->getType())->getNumElements() == 2)
+                    cast<IGCLLVM::FixedVectorType>(bitCastInst->getOperand(0)->getType())->getElementType()->isIntegerTy(32) &&
+                    cast<IGCLLVM::FixedVectorType>(bitCastInst->getOperand(0)->getType())->getNumElements() == 2)
                 {
                     InsertElementInst* insertElementInst = cast<InsertElementInst>(bitCastInst->getOperand(0));
 
@@ -2979,7 +2979,7 @@ void GenSpecificPattern::visitFNeg(llvm:
     }
     else
     {
-        uint32_t vectorSize = cast<VectorType>(I.getType())->getNumElements();
+        uint32_t vectorSize = cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements();
         fsub = llvm::UndefValue::get(I.getType());
 
         for (uint32_t i = 0; i < vectorSize; ++i)
@@ -3056,7 +3056,7 @@ Constant* IGCConstProp::replaceShaderCon
                 if (inst->getType()->isVectorTy())
                 {
                     Type* srcEltTy = cast<VectorType>(inst->getType())->getElementType();
-                    uint32_t srcNElts = (uint32_t)cast<VectorType>(inst->getType())->getNumElements();
+                    uint32_t srcNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements();
                     uint32_t eltSize_in_bytes = (unsigned int)srcEltTy->getPrimitiveSizeInBits() / 8;
                     IRBuilder<> builder(inst);
                     Value* vectorValue = UndefValue::get(inst->getType());
@@ -3341,7 +3341,7 @@ Constant* IGCConstProp::ConstantFoldCmpI
     {
         bool AllTrue = true, AllFalse = true;
         auto VecOpnd = cast<Constant>(EEI->getVectorOperand());
-        unsigned N = (unsigned)cast<VectorType>(VecOpnd->getType())->getNumElements();
+        unsigned N = (unsigned)cast<IGCLLVM::FixedVectorType>(VecOpnd->getType())->getNumElements();
         for (unsigned i = 0; i < N; ++i)
         {
             Constant* const Opnd = VecOpnd->getAggregateElement(i);
@@ -4137,8 +4137,8 @@ namespace IGC
                 BitCastInst* BC = dyn_cast<BitCastInst>(&*BI++);
                 if (!BC) continue;
                 // Skip non-element-wise bitcast.
-                VectorType* DstVTy = dyn_cast<VectorType>(BC->getType());
-                VectorType* SrcVTy = dyn_cast<VectorType>(BC->getOperand(0)->getType());
+                IGCLLVM::FixedVectorType* DstVTy = dyn_cast<IGCLLVM::FixedVectorType>(BC->getType());
+                IGCLLVM::FixedVectorType* SrcVTy = dyn_cast<IGCLLVM::FixedVectorType>(BC->getOperand(0)->getType());
                 if (!DstVTy || !SrcVTy || DstVTy->getNumElements() != SrcVTy->getNumElements())
                     continue;
                 // Skip if it's not used only all extractelement.
@@ -4928,7 +4928,7 @@ void SplitIndirectEEtoSel::visitExtractE
 {
     using namespace llvm::PatternMatch;
 
-    VectorType* vecTy = I.getVectorOperandType();
+    IGCLLVM::FixedVectorType* vecTy = dyn_cast<IGCLLVM::FixedVectorType>(I.getVectorOperandType());
     uint64_t num = vecTy->getNumElements();
     Type* eleType = vecTy->getElementType();
 
--- a/IGC/Compiler/DebugInfo/ScalarVISAModule.cpp
+++ b/IGC/Compiler/DebugInfo/ScalarVISAModule.cpp
@@ -15,6 +15,7 @@ SPDX-License-Identifier: MIT
 #include "DebugInfo/DebugInfoUtils.hpp"
 
 #include "common/LLVMWarningsPush.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/Module.h"
 #include "common/LLVMWarningsPop.hpp"
@@ -565,7 +566,7 @@ ScalarVisaModule::GetVariableLocation(co
 
         if (pType->isVectorTy())
         {
-            vectorNumElements = (unsigned)cast<VectorType>(pType)->getNumElements();
+            vectorNumElements = (unsigned)cast<IGCLLVM::FixedVectorType>(pType)->getNumElements();
         }
         else if (!pVar->IsUniform())
         {
--- a/IGC/Compiler/GenTTI.cpp
+++ b/IGC/Compiler/GenTTI.cpp
@@ -21,6 +21,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Analysis/LoopInfo.h"
 #include "llvm/Analysis/ScalarEvolution.h"
 #include "llvm/Support/raw_ostream.h"
+#include "llvmWrapper/Transforms/Utils/LoopUtils.h"
 #include "common/LLVMWarningsPop.hpp"
 
 using namespace llvm;
@@ -201,7 +202,7 @@ namespace llvm {
 
         // Skip non-simple loop.
         if (L->getNumBlocks() != 1) {
-            if (IGC_IS_FLAG_ENABLED(EnableAdvRuntimeUnroll) && L->empty()) {
+            if (IGC_IS_FLAG_ENABLED(EnableAdvRuntimeUnroll) && IGCLLVM::isInnermost(L)) {
                 auto countNonPHI = [](BasicBlock* BB) {
                     unsigned Total = BB->size();
                     unsigned PHIs = 0;
--- a/IGC/Compiler/GenUpdateCB.cpp
+++ b/IGC/Compiler/GenUpdateCB.cpp
@@ -8,6 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "common/LLVMWarningsPush.hpp"
 #include "llvmWrapper/Bitcode/BitcodeWriter.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include <llvm/Support/ScaledNumber.h>
 #include <llvm/Bitcode/BitcodeReader.h>
 #include "llvm/IR/DebugInfo.h"
@@ -368,7 +369,7 @@ bool GenUpdateCB::runOnFunction(Function
                     isResInfo(dyn_cast<GenIntrinsicInst>(inst,
                         GenISAIntrinsic::GenISA_resinfoptr), texId, lod, isUAV))
                 {
-                    unsigned nelems = (unsigned)cast<VectorType>(inst->getType())->getNumElements();
+                    unsigned nelems = (unsigned)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements();
                     SmallVector< SmallVector<ExtractElementInst*, 1>, 4> extracts(nelems);
                     if (VectorUsedByConstExtractOnly(inst, extracts))
                     {
--- a/IGC/Compiler/HandleFRemInstructions.cpp
+++ b/IGC/Compiler/HandleFRemInstructions.cpp
@@ -12,6 +12,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/Instructions.h>
 #include <llvm/IR/InstIterator.h>
 #include <llvm/Transforms/Utils/BasicBlockUtils.h>
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/IGCPassSupport.h"
 #include "Probe/Assertion.h"
@@ -61,7 +62,7 @@ void HandleFRemInstructions::visitFRem(l
 
     if (ValType->isVectorTy())
     {
-        auto VecCount = cast<VectorType>(ValType)->getNumElements();
+        auto VecCount = cast<IGCLLVM::FixedVectorType>(ValType)->getNumElements();
         if (VecCount == 2 || VecCount == 3 || VecCount == 4 || VecCount == 8 || VecCount == 16)
         {
             VecStr = "v" + std::to_string(VecCount);
--- a/IGC/Compiler/HandleLoadStoreInstructions.cpp
+++ b/IGC/Compiler/HandleLoadStoreInstructions.cpp
@@ -61,7 +61,7 @@ void HandleLoadStoreInstructions::visitL
 
         if (I.getType()->isVectorTy())
         {
-            numVectorElements = (uint32_t)cast<VectorType>(I.getType())->getNumElements();
+            numVectorElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements();
             doubleDstType = IGCLLVM::FixedVectorType::get(builder.getDoubleTy(), numVectorElements);
         }
         uint as = ptrv->getType()->getPointerAddressSpace();
@@ -134,7 +134,7 @@ void HandleLoadStoreInstructions::visitS
 
         if (I.getValueOperand()->getType()->isVectorTy())
         {
-            numVectorElements = (uint32_t)cast<VectorType>(I.getValueOperand()->getType())->getNumElements();
+            numVectorElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(I.getValueOperand()->getType())->getNumElements();
         }
 
 
--- a/IGC/Compiler/LegalizationPass.cpp
+++ b/IGC/Compiler/LegalizationPass.cpp
@@ -671,7 +671,7 @@ void Legalization::visitBitCastInst(llvm
         if (!isa<TruncInst>(pZ->getOperand(0)))
             return;
 
-        auto* pVecTy = cast<VectorType>(pZ->getDestTy());
+        auto* pVecTy = cast<IGCLLVM::FixedVectorType>(pZ->getDestTy());
         if (pVecTy->getNumElements() != 3)
             return;
 
@@ -766,7 +766,7 @@ void Legalization::visitSelectInst(Selec
     }
     else if (I.getType()->isVectorTy())
     {
-        unsigned int vecSize = (unsigned)cast<VectorType>(I.getType())->getNumElements();
+        unsigned int vecSize = (unsigned)cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements();
         Value* newVec = UndefValue::get(I.getType());
         m_builder->SetInsertPoint(&I);
         for (unsigned int i = 0; i < vecSize; i++)
@@ -1148,7 +1148,7 @@ void Legalization::visitStoreInst(StoreI
     if (ConstantDataVector * vec = dyn_cast<ConstantDataVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementAsConstant(i);
@@ -1168,7 +1168,7 @@ void Legalization::visitStoreInst(StoreI
     else if (ConstantVector * vec = dyn_cast<ConstantVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getOperand(i);
@@ -1188,7 +1188,7 @@ void Legalization::visitStoreInst(StoreI
     else if (ConstantAggregateZero * vec = dyn_cast<ConstantAggregateZero>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementValue(i);
@@ -1338,7 +1338,7 @@ void Legalization::visitInsertElementIns
     if (ConstantDataVector * vec = dyn_cast<ConstantDataVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementAsConstant(i);
@@ -1358,7 +1358,7 @@ void Legalization::visitInsertElementIns
     else if (ConstantVector * vec = dyn_cast<ConstantVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(I.getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getOperand(i);
@@ -1378,7 +1378,7 @@ void Legalization::visitInsertElementIns
     else if (ConstantAggregateZero * vec = dyn_cast<ConstantAggregateZero>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(I.getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementValue(i);
@@ -1395,7 +1395,7 @@ void Legalization::visitInsertElementIns
     else if (I.getOperand(1)->getType()->isIntegerTy(1))
     {
         // This promotes i1 insertelement to i32
-        unsigned int nbElement = (unsigned)cast<VectorType>(I.getOperand(0)->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(I.getOperand(0)->getType())->getNumElements();
         Value* newVec = UndefValue::get(IGCLLVM::FixedVectorType::get(m_builder->getInt32Ty(), nbElement));
         PromoteInsertElement(&I, newVec);
     }
@@ -1408,7 +1408,7 @@ void Legalization::visitShuffleVectorIns
     // If the original vector is a constant, just use the scalar constant,
     // otherwise extract from the original vector.
 
-    VectorType* resType = cast<VectorType>(I.getType());
+    IGCLLVM::FixedVectorType* resType = cast<IGCLLVM::FixedVectorType>(I.getType());
     Value* newVec = UndefValue::get(resType);
     Value* src0 = I.getOperand(0);
     Value* src1 = I.getOperand(1);
@@ -1419,7 +1419,7 @@ void Legalization::visitShuffleVectorIns
     Constant* mask = I.getShuffleMaskForBitcode();
 #endif
     // The two inputs are guaranteed to be of the same type
-    VectorType* inType = cast<VectorType>(src0->getType());
+    IGCLLVM::FixedVectorType* inType = cast<IGCLLVM::FixedVectorType>(src0->getType());
     int inCount = int_cast<int>(inType->getNumElements());
     int inBase = 2;  // 2 means using undef
     // if inType == resType, use src0/src1 as the input
@@ -1635,7 +1635,7 @@ Type* Legalization::LegalAllocaType(Type
 #endif
         legalType = IGCLLVM::FixedVectorType::get(
             LegalAllocaType(cast<VectorType>(type)->getElementType()),
-            (unsigned)cast<VectorType>(type)->getNumElements());
+            (unsigned)cast<IGCLLVM::FixedVectorType>(type)->getNumElements());
         break;
     case Type::StructTyID:
         return LegalStructAllocaType(type);
@@ -1976,7 +1976,7 @@ void Legalization::visitIntrinsicInst(ll
         Value* newValue = nullptr;
         if (srcType->isVectorTy())
         {
-            auto sourceVT = cast<VectorType>(srcType);
+            auto sourceVT = cast<IGCLLVM::FixedVectorType>(srcType);
             const unsigned int numElements = (uint32_t)sourceVT->getNumElements();
             Value* dstVec = UndefValue::get(srcType);
             for (unsigned int i = 0; i < numElements; ++i)
@@ -2119,7 +2119,7 @@ void Legalization::visitTruncInst(llvm::
     }
 
     Src = BC->getOperand(0);
-    VectorType* VTy = dyn_cast<VectorType>(Src->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Src->getType());
     // Bail out if it's not bitcasted from <3 x i16>
     if (!VTy || VTy->getNumElements() != 3 || !VTy->getElementType()->isIntegerTy(16))
         return;
--- a/IGC/Compiler/Legalizer/InstPromoter.cpp
+++ b/IGC/Compiler/Legalizer/InstPromoter.cpp
@@ -9,6 +9,7 @@ SPDX-License-Identifier: MIT
 #define DEBUG_TYPE "type-legalizer"
 #include "TypeLegalizer.h"
 #include "InstPromoter.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/MathExtras.h"
@@ -382,7 +383,7 @@ bool InstPromoter::visitBitCastInst(BitC
             IRB->CreateBitCast(Val, IGCLLVM::FixedVectorType::get(DestTy->getScalarType(), N));
 
         std::vector<Constant*> Vals;
-        for (unsigned i = 0; i < (unsigned)cast<VectorType>(DestTy)->getNumElements(); i++)
+        for (unsigned i = 0; i < (unsigned)cast<IGCLLVM::FixedVectorType>(DestTy)->getNumElements(); i++)
             Vals.push_back(IRB->getInt32(i));
 
         Value* Mask = ConstantVector::get(Vals);
--- a/IGC/Compiler/Legalizer/InstScalarizer.cpp
+++ b/IGC/Compiler/Legalizer/InstScalarizer.cpp
@@ -114,7 +114,7 @@ bool InstScalarizer::visitLoadInst(LoadI
         // otherwise, it's broken.
         IGC_ASSERT(TL->getTypeSizeInBits(EltTy) == TL->getTypeStoreSizeInBits(EltTy));
 
-        unsigned NumElts = (unsigned)cast<VectorType>(OrigTy)->getNumElements();
+        unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(OrigTy)->getNumElements();
         unsigned Elt = 0;
 
         Type* NewPtrTy = PointerType::get(EltTy, AS);
@@ -252,7 +252,7 @@ bool InstScalarizer::visitStoreInst(Stor
         // otherwise, it's broken.
         IGC_ASSERT(TL->getTypeSizeInBits(EltTy) == TL->getTypeStoreSizeInBits(EltTy));
 
-        unsigned NumElts = (unsigned)cast<VectorType>(OrigTy)->getNumElements();
+        unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(OrigTy)->getNumElements();
         unsigned Elt = 0;
 
         Type* NewPtrTy = PointerType::get(EltTy, AS);
@@ -482,7 +482,7 @@ bool InstScalarizer::visitInsertElementI
     IGC_ASSERT(EltSeq->size());
     IGC_ASSERT(VecSeqCopy.size() % EltSeq->size() == 0);
 
-    unsigned NumElts = (unsigned)cast<VectorType>(I.getOperand(0)->getType())->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(I.getOperand(0)->getType())->getNumElements();
     unsigned i = 0;
     for (unsigned Elt = 0; Elt != NumElts; ++Elt) {
         if (Elt == Idx) {
--- a/IGC/Compiler/Legalizer/PeepholeTypeLegalizer.cpp
+++ b/IGC/Compiler/Legalizer/PeepholeTypeLegalizer.cpp
@@ -146,7 +146,7 @@ void PeepholeTypeLegalizer::legalizePhiI
 
     if (quotient > 1)
     {
-        unsigned numElements = I.getType()->isVectorTy() ? (unsigned)cast<VectorType>(I.getType())->getNumElements() : 1;
+        unsigned numElements = I.getType()->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements() : 1;
         Type* newType = IGCLLVM::FixedVectorType::get(Type::getIntNTy(I.getContext(), promoteToInt), quotient * numElements);
 
         PHINode* newPhi = m_builder->CreatePHI(newType, oldPhi->getNumIncomingValues());
@@ -207,7 +207,7 @@ void PeepholeTypeLegalizer::legalizeExtr
     unsigned elementWidth = extract->getType()->getScalarSizeInBits();
     if (!isLegalInteger(elementWidth) && extract->getType()->isIntOrIntVectorTy())
     {
-        unsigned numElements = (unsigned)cast<VectorType>(extract->getOperand(0)->getType())->getNumElements();
+        unsigned numElements = (unsigned)cast<IGCLLVM::FixedVectorType>(extract->getOperand(0)->getType())->getNumElements();
         unsigned quotient, promoteToInt;
         promoteInt(elementWidth, quotient, promoteToInt, DL->getLargestLegalIntTypeSizeInBits());
 
@@ -834,7 +834,7 @@ void PeepholeTypeLegalizer::cleanupZExtI
         }
 
         unsigned ipElmtSize = prevInst->getOperand(0)->getType()->getScalarSizeInBits();
-        unsigned ipVecSize = (unsigned)cast<VectorType>(prevInst->getOperand(0)->getType())->getNumElements();
+        unsigned ipVecSize = (unsigned)cast<IGCLLVM::FixedVectorType>(prevInst->getOperand(0)->getType())->getNumElements();
         unsigned convFactor = promoteToInt / ipElmtSize;
 
         Value* vecRes = UndefValue::get(IGCLLVM::FixedVectorType::get(llvm::Type::getIntNTy(I.getContext(), promoteToInt), quotient));
--- a/IGC/Compiler/Legalizer/TypeLegalizer.cpp
+++ b/IGC/Compiler/Legalizer/TypeLegalizer.cpp
@@ -16,6 +16,7 @@ SPDX-License-Identifier: MIT
 #include "InstScalarizer.h"
 #include "InstElementizer.h"
 #include "common/LLVMWarningsPush.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/ADT/PostOrderIterator.h"
 #include "llvm/IR/CFG.h"
 #include "llvm/Support/Debug.h"
@@ -274,7 +275,7 @@ TypeSeq* TypeLegalizer::getScalarizedTyp
     }
 
     Type* EltTy = cast<VectorType>(Ty)->getElementType();
-    for (unsigned i = 0, e = (unsigned)cast<VectorType>(Ty)->getNumElements(); i != e; ++i)
+    for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements(); i != e; ++i)
         TMI->second.push_back(EltTy);
 
     return &TMI->second;
--- a/IGC/Compiler/Legalizer/TypeLegalizer.h
+++ b/IGC/Compiler/Legalizer/TypeLegalizer.h
@@ -12,6 +12,7 @@ SPDX-License-Identifier: MIT
 #include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/Analysis/InlineCost.h"
 #include "llvmWrapper/IR/InstrTypes.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/Support/Alignment.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/DenseMap.h"
@@ -271,7 +272,7 @@ namespace IGC {
                 if (!Ty->isVectorTy())
                     return false;
 
-                unsigned NumElts = (unsigned)cast<VectorType>(Ty)->getNumElements();
+                unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
                 Type* EltTy = cast<VectorType>(Ty)->getElementType();
                 const auto& ProfitLengths = getProfitLoadVectorLength(EltTy);
 
--- a/IGC/Compiler/LowPrecisionOptPass.cpp
+++ b/IGC/Compiler/LowPrecisionOptPass.cpp
@@ -253,7 +253,7 @@ bool LowPrecisionOpt::propagateSamplerTy
 
     if (I.getType()->isVectorTy())
     {
-        numberOfElements = int_cast<unsigned int>(cast<VectorType>(I.getType())->getNumElements());
+        numberOfElements = int_cast<unsigned int>(cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements());
     }
 
     llvm::SmallVector<llvm::Type*, 4> overloadTys;
--- a/IGC/Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.cpp
@@ -8,6 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.hpp"
 #include "Compiler/IGCPassSupport.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/IR/Function.h"
 #include "common/LLVMWarningsPop.hpp"
@@ -114,7 +115,7 @@ static uint64_t getNumElements(Type* typ
     {
         return arrayType->getNumElements();
     }
-    if (VectorType * vectorType = dyn_cast<VectorType>(type))
+    if (IGCLLVM::FixedVectorType * vectorType = dyn_cast<IGCLLVM::FixedVectorType>(type))
     {
         return vectorType->getNumElements();
     }
--- a/IGC/Compiler/Optimizer/OpenCLPasses/CorrectlyRoundedDivSqrt/CorrectlyRoundedDivSqrt.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/CorrectlyRoundedDivSqrt/CorrectlyRoundedDivSqrt.cpp
@@ -11,6 +11,7 @@ SPDX-License-Identifier: MIT
 #include "Compiler/IGCPassSupport.h"
 #include "GenISAIntrinsics/GenIntrinsicInst.h"
 
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/IR/Function.h>
 #include <llvm/IR/Instructions.h>
@@ -117,7 +118,7 @@ Value* CorrectlyRoundedDivSqrt::emitIEEE
     }
     else
     {
-        auto vType = dyn_cast<VectorType>(Ty);
+        auto vType = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
         unsigned VecLen = (uint32_t)vType->getNumElements();
         Divide = UndefValue::get(Ty);
         for (unsigned i = 0; i < VecLen; i++)
--- a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
@@ -937,7 +937,7 @@ namespace //Anonymous
         {
             auto ndrangeStructName = "struct.ndrange_t";
             auto module = _deviceExecCall->getModule();
-            auto ndrangeTy = module->getTypeByName(ndrangeStructName);
+            auto ndrangeTy = IGCLLVM::getTypeByName(module, ndrangeStructName);
             if (ndrangeTy == nullptr)
             {
                 //create struct type
@@ -1682,7 +1682,7 @@ namespace //Anonymous
                     // this generates <element_type><num_elements> string. Ie for char2 element_type is char and num_elements is 2
                     // that is done by callin BaseTypeName on vector element type, this recursive call has only a depth of one since
                     // there are no compound vectors in OpenCL.
-                    auto vType = llvm::dyn_cast<VectorType>(type);
+                    auto vType = llvm::dyn_cast<IGCLLVM::FixedVectorType>(type);
                     return BaseTypeName(type->getContainedType(0), os) << vType->getNumElements();
                 }
                 default:
--- a/IGC/Compiler/Optimizer/OpenCLPasses/KernelArgs.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/KernelArgs.cpp
@@ -8,6 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "Compiler/Optimizer/OpenCLPasses/KernelArgs.hpp"
 #include "AdaptorCommon/ImplicitArgs.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/IR/Argument.h>
 #include <llvm/IR/DataLayout.h>
@@ -372,7 +373,7 @@ unsigned int KernelArg::calcAssociatedAr
 
 unsigned int KernelArg::getNumComponents() const
 {
-    if (VectorType * vecType = dyn_cast<VectorType>(m_arg->getType()))
+    if (IGCLLVM::FixedVectorType * vecType = dyn_cast<IGCLLVM::FixedVectorType>(m_arg->getType()))
     {
         // Vector
         return int_cast<unsigned int>(vecType->getNumElements());
--- a/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
@@ -723,7 +723,7 @@ Value* OpenCLPrintfResolution::fixupPrin
             }
 
             Type* newType = Type::getFloatTy(arg->getContext());
-            if (auto argVT = dyn_cast<VectorType>(arg->getType()))
+            if (auto argVT = dyn_cast<IGCLLVM::FixedVectorType>(arg->getType()))
             {
                 newType = IGCLLVM::FixedVectorType::get(newType, (unsigned)argVT->getNumElements());
             }
@@ -753,7 +753,7 @@ void OpenCLPrintfResolution::preprocessP
         IGC::SHADER_PRINTF_TYPE argDataType = getPrintfArgDataType(arg);
         arg = fixupPrintfArg(printfCall, arg, argDataType);
         uint vecSize = 0;
-        if (auto argVType = dyn_cast<VectorType>(argType)) {
+        if (auto argVType = dyn_cast<IGCLLVM::FixedVectorType>(argType)) {
             vecSize = (uint)argVType->getNumElements();
         }
         m_argDescriptors.push_back(SPrintfArgDescriptor(argDataType, arg, vecSize));
--- a/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.cpp
@@ -13,6 +13,7 @@ SPDX-License-Identifier: MIT
 #include "Compiler/IGCPassSupport.h"
 #include "Compiler/CISACodeGen/GenCodeGenModule.h"
 #include "Compiler/CISACodeGen/LowerGEPForPrivMem.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/Transforms/Utils/Local.h"
@@ -618,7 +619,7 @@ public:
             Type* scalarptrTy = PointerType::get(scalarType, pLoad->getPointerAddressSpace());
             IGC_ASSERT(scalarType->getPrimitiveSizeInBits() / 8 == elementSize);
             Value* vec = UndefValue::get(pLoad->getType());
-            auto pLoadVT = cast<VectorType>(pLoad->getType());
+            auto pLoadVT = cast<IGCLLVM::FixedVectorType>(pLoad->getType());
             for (unsigned i = 0, e = (unsigned)pLoadVT->getNumElements(); i < e; ++i)
             {
                 Value* ptr = IRB.CreateIntToPtr(address, scalarptrTy);
@@ -657,7 +658,7 @@ public:
             IGC_ASSERT(scalarType->getPrimitiveSizeInBits() / 8 == elementSize);
             Value* vec = pStore->getValueOperand();
 
-            unsigned vecNumElts = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+            unsigned vecNumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
             for (unsigned i = 0; i < vecNumElts; ++i)
             {
                 Value* ptr = IRB.CreateIntToPtr(address, scalarptrTy);
@@ -728,7 +729,7 @@ bool PrivateMemoryResolution::testTransp
         }
         else if(pTmpType->isVectorTy())
         {
-            auto pTmpVType = cast<VectorType>(pTmpType);
+            auto pTmpVType = cast<IGCLLVM::FixedVectorType>(pTmpType);
             tmpAllocaSize *= pTmpVType->getNumElements();
             pTmpType = pTmpType->getContainedType(0);
             ok = (nullptr != pTmpType);
@@ -833,6 +834,8 @@ bool PrivateMemoryResolution::resolveAll
 
     // Construct an empty DebugLoc.
     IF_DEBUG_INFO(DebugLoc entryDebugLoc);
+    // Assign with the function location if available.
+    IF_DEBUG_INFO_IF(DISubprogram *subprogram = m_currFunction->getSubprogram(), entryDebugLoc = DILocation::get(subprogram->getContext(), subprogram->getLine(), 0, subprogram););
     IF_DEBUG_INFO(entryBuilder.SetCurrentDebugLocation(entryDebugLoc));
 
     if (privateOnStack)
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
@@ -238,7 +238,7 @@ Instruction* ReplaceUnsupportedIntrinsic
 Value* ReplaceUnsupportedIntrinsics::replicateScalar(
     Value* ScalarVal, Type* Ty, Instruction* InsertBefore)
 {
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     Type* ETy = VTy ? VTy->getElementType() : Ty;
     uint32_t sBits = (unsigned int)ScalarVal->getType()->getPrimitiveSizeInBits();
     uint32_t nBits = (unsigned int)ETy->getPrimitiveSizeInBits();
@@ -899,7 +899,7 @@ void ReplaceUnsupportedIntrinsics::repla
     }
 
     Value* numBits = Builder.getIntN(sizeInBits, sizeInBits);
-    if (auto IVT = dyn_cast<VectorType>(I->getType())) {
+    if (auto IVT = dyn_cast<IGCLLVM::FixedVectorType>(I->getType())) {
         numBits = ConstantVector::getSplat(IGCLLVM::getElementCount((uint32_t)IVT->getNumElements()), cast<Constant>(numBits));
     }
     auto shiftModulo = Builder.CreateURem(I->getArgOperand(2), numBits);
--- a/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
@@ -277,7 +277,7 @@ static Value* BuildLoadInst(CallInst& CI
     // It Offset is aligned, it returns result of LoadInst of type DataType.
     auto ElemByteSize = DataType->getScalarSizeInBits() / 8;
     auto Size = ElemByteSize;
-    if (auto DataVecType = dyn_cast<VectorType>(DataType))
+    if (auto DataVecType = dyn_cast<IGCLLVM::FixedVectorType>(DataType))
     {
         Size *= (unsigned int)DataVecType->getNumElements();
     }
--- a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
+++ b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
@@ -339,7 +339,7 @@ bool PreCompiledFuncImport::preProcessDo
                     }
                     else
                     {
-                        uint32_t vectorSize = cast<VectorType>(Inst->getType())->getNumElements();
+                        uint32_t vectorSize = cast<IGCLLVM::FixedVectorType>(Inst->getType())->getNumElements();
                         fsub = llvm::UndefValue::get(Inst->getType());
 
                         for (uint32_t i = 0; i < vectorSize; ++i)
@@ -1002,7 +1002,7 @@ void PreCompiledFuncImport::processDivid
 
     Type* argumentType = inst.getOperand(0)->getType();
 
-    if (auto argumentVType = dyn_cast<VectorType>(argumentType))
+    if (auto argumentVType = dyn_cast<IGCLLVM::FixedVectorType>(argumentType))
     {
         numElements = (unsigned)argumentVType->getNumElements();
     }
--- a/IGC/Compiler/Optimizer/Scalarizer.cpp
+++ b/IGC/Compiler/Optimizer/Scalarizer.cpp
@@ -403,7 +403,7 @@ void ScalarizeFunction::scalarizeInstruc
 {
     V_PRINT(scalarizer, "\t\tBinary instruction\n");
     IGC_ASSERT_MESSAGE(BI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(BI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(BI->getType());
     // Only need handling for vector binary ops
     if (!instType) return;
 
@@ -463,7 +463,7 @@ void ScalarizeFunction::scalarizeInstruc
 {
     V_PRINT(scalarizer, "\t\tCompare instruction\n");
     IGC_ASSERT_MESSAGE(CI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(CI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(CI->getType());
     // Only need handling for vector compares
     if (!instType) return;
 
@@ -511,13 +511,13 @@ void ScalarizeFunction::scalarizeInstruc
 {
     V_PRINT(scalarizer, "\t\tCast instruction\n");
     IGC_ASSERT_MESSAGE(CI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(CI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(CI->getType());
 
     // For BitCast - we only scalarize if src and dst types have same vector length
     if (isa<BitCastInst>(CI))
     {
         if (!instType) return recoverNonScalarizableInst(CI);
-        VectorType* srcType = dyn_cast<VectorType>(CI->getOperand(0)->getType());
+        IGCLLVM::FixedVectorType* srcType = dyn_cast<IGCLLVM::FixedVectorType>(CI->getOperand(0)->getType());
         if (!srcType || (instType->getNumElements() != srcType->getNumElements()))
         {
             return recoverNonScalarizableInst(CI);
@@ -572,7 +572,7 @@ void ScalarizeFunction::scalarizeInstruc
 {
     V_PRINT(scalarizer, "\t\tPHI instruction\n");
     IGC_ASSERT_MESSAGE(PI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(PI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(PI->getType());
     // Only need handling for vector PHI
     if (!instType) return;
 
@@ -683,7 +683,7 @@ void ScalarizeFunction::scalarizeInstruc
 {
     V_PRINT(scalarizer, "\t\tSelect instruction\n");
     IGC_ASSERT_MESSAGE(SI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(SI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(SI->getType());
     // Only need handling for vector select
     if (!instType) return;
 
@@ -765,7 +765,7 @@ void ScalarizeFunction::scalarizeInstruc
 
     // Connect the "extracted" value to all its consumers
     uint64_t scalarIndex = cast<ConstantInt>(scalarIndexVal)->getZExtValue();
-    auto valueVType = cast<VectorType>(vectorValue->getType());
+    auto valueVType = cast<IGCLLVM::FixedVectorType>(vectorValue->getType());
     if (static_cast<unsigned int>(scalarIndex) < (unsigned)valueVType->getNumElements())
     {
         IGC_ASSERT_MESSAGE(NULL != operand[static_cast<unsigned int>(scalarIndex)], "SCM error");
@@ -829,7 +829,7 @@ void ScalarizeFunction::scalarizeInstruc
     if (isa<UndefValue>(sourceVectorValue))
     {
         // Scalarize the undef value (generate a scalar undef)
-        VectorType* inputVectorType = dyn_cast<VectorType>(sourceVectorValue->getType());
+        IGCLLVM::FixedVectorType* inputVectorType = dyn_cast<IGCLLVM::FixedVectorType>(sourceVectorValue->getType());
         IGC_ASSERT_MESSAGE(inputVectorType, "expected vector argument");
 
         UndefValue* undefVal = UndefValue::get(inputVectorType->getElementType());
@@ -870,7 +870,7 @@ void ScalarizeFunction::scalarizeInstruc
     IGC_ASSERT(nullptr != sourceVector0Value);
     Value* sourceVector1Value = SI->getOperand(1);
     IGC_ASSERT(nullptr != sourceVector1Value);
-    VectorType* const inputType = dyn_cast<VectorType>(sourceVector0Value->getType());
+    IGCLLVM::FixedVectorType* const inputType = dyn_cast<IGCLLVM::FixedVectorType>(sourceVector0Value->getType());
     IGC_ASSERT_MESSAGE(nullptr != inputType, "vector input error");
     IGC_ASSERT_MESSAGE(inputType == sourceVector1Value->getType(), "vector input error");
     unsigned sourceVectorWidth = int_cast<unsigned>(inputType->getNumElements());
@@ -892,7 +892,7 @@ void ScalarizeFunction::scalarizeInstruc
 
     // Generate array for shuffled scalar values
     SmallVector<Value*, MAX_INPUT_VECTOR_WIDTH>newVector;
-    unsigned width = int_cast<unsigned>(SI->getType()->getNumElements());
+    unsigned width = int_cast<unsigned>(cast<IGCLLVM::FixedVectorType>(SI->getType())->getNumElements());
 
     // Generate undef value, which may be needed as some scalar elements
     UndefValue* undef = UndefValue::get(inputType->getElementType());
@@ -961,7 +961,7 @@ void ScalarizeFunction::scalarizeInstruc
 
     if (baseValue->getType()->isVectorTy())
     {
-        width = int_cast<unsigned>(dyn_cast<VectorType>(baseValue->getType())->getNumElements());
+        width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(baseValue->getType())->getNumElements());
         // Obtain the scalarized operands
         obtainScalarizedValues(operand1, NULL, baseValue, GI);
         ptrTy = dyn_cast<VectorType>(baseValue->getType())->getElementType();
@@ -972,7 +972,7 @@ void ScalarizeFunction::scalarizeInstruc
     }
     if (indexValue->getType()->isVectorTy())
     {
-        width = int_cast<unsigned>(dyn_cast<VectorType>(indexValue->getType())->getNumElements());
+        width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(indexValue->getType())->getNumElements());
         // Obtain the scalarized operands
         obtainScalarizedValues(operand2, NULL, indexValue, GI);
     }
@@ -1011,7 +1011,7 @@ void ScalarizeFunction::obtainScalarized
 {
     V_PRINT(scalarizer, "\t\t\tObtaining scalar value... " << *origValue << "\n");
 
-    VectorType* origType = dyn_cast<VectorType>(origValue->getType());
+    IGCLLVM::FixedVectorType* origType = dyn_cast<IGCLLVM::FixedVectorType>(origValue->getType());
     IGC_ASSERT_MESSAGE(origType, "Value must have a vector type!");
     unsigned width = int_cast<unsigned>(origType->getNumElements());
 
@@ -1170,7 +1170,7 @@ void ScalarizeFunction::obtainVectorValu
     }
 
     Value* assembledVector = UndefValue::get(vectorVal->getType());
-    unsigned width = int_cast<unsigned>(dyn_cast<VectorType>(vectorVal->getType())->getNumElements());
+    unsigned width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(vectorVal->getType())->getNumElements());
     for (unsigned i = 0; i < width; i++)
     {
         IGC_ASSERT_MESSAGE(NULL != valueEntry->scalarValues[i], "SCM entry has NULL value");
@@ -1230,7 +1230,7 @@ void ScalarizeFunction::updateSCMEntryWi
     bool matchDbgLoc)
 {
     IGC_ASSERT_MESSAGE((origValue->getType()->isArrayTy() || origValue->getType()->isVectorTy()), "only Vector values are supported");
-    unsigned width = int_cast<unsigned>(dyn_cast<VectorType>(origValue->getType())->getNumElements());
+    unsigned width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(origValue->getType())->getNumElements());
 
     entry->isOriginalVectorRemoved = isOrigValueRemoved;
 
@@ -1301,7 +1301,7 @@ void ScalarizeFunction::resolveDeferredI
         Instruction* vectorInst = dyn_cast<Instruction>(current.unresolvedInst);
         IGC_ASSERT_MESSAGE(vectorInst, "DRL only handles unresolved instructions");
 
-        VectorType* currType = dyn_cast<VectorType>(vectorInst->getType());
+        IGCLLVM::FixedVectorType* currType = dyn_cast<IGCLLVM::FixedVectorType>(vectorInst->getType());
         IGC_ASSERT_MESSAGE(currType, "Cannot have DRL of non-vector value");
         unsigned width = int_cast<unsigned>(currType->getNumElements());
 
--- a/IGC/Compiler/Optimizer/ValueTracker.cpp
+++ b/IGC/Compiler/Optimizer/ValueTracker.cpp
@@ -162,7 +162,7 @@ Value* ValueTracker::handleExtractElemen
         {
             auto mask = I->getShuffleMask();
             uint shuffleidx = int_cast<uint>(mask[(uint)idx]);
-            auto vType = dyn_cast<VectorType>(I->getOperand(0)->getType());
+            auto vType = dyn_cast<IGCLLVM::FixedVectorType>(I->getOperand(0)->getType());
             baseValue = (shuffleidx < vType->getNumElements()) ?
                 I->getOperand(0) : I->getOperand(1);
         }
--- a/IGC/Compiler/VerificationPass.cpp
+++ b/IGC/Compiler/VerificationPass.cpp
@@ -286,7 +286,7 @@ bool VerificationPass::verifyType(Type*
 
     case IGCLLVM::VectorTyID:
     {
-        auto VType = cast<VectorType>(type);
+        auto VType = cast<IGCLLVM::FixedVectorType>(type);
         unsigned typeSize = (unsigned)VType->getNumElements();
         if (!m_IGC_IR_spec.vectorTypeSizes.count(typeSize))
         {
--- a/IGC/DebugInfo/DebugInfoUtils.hpp
+++ b/IGC/DebugInfo/DebugInfoUtils.hpp
@@ -92,7 +92,7 @@ namespace IGC
                 IGCLLVM::DIBuilder Builder(M);
                 llvm::DIGlobalVariable* GV = GVs[j]->getVariable();
                 llvm::DIScope* scopeToUse = GV->getScope();
-                llvm::DILocation* locToUse = llvm::DebugLoc::get(GV->getLine(), 0, scopeToUse, loc);
+                llvm::DILocation* locToUse = llvm::DILocation::get(scopeToUse->getContext(), GV->getLine(), 0, scopeToUse, loc);
                 if (llvm::isa<llvm::DICompileUnit>(GV->getScope()))
                 {
                     // Function has no DebugLoc so it is either internal
--- a/IGC/DebugInfo/DwarfDebug.cpp
+++ b/IGC/DebugInfo/DwarfDebug.cpp
@@ -1993,9 +1993,9 @@ static DebugLoc getFnDebugLoc(DebugLoc D
         // Check for number of operands since the compatibility is cheap here.
         if (SP->getNumOperands() > 19)
         {
-            return DebugLoc::get(SP->getScopeLine(), 0, SP);
+            return DILocation::get(SP->getContext(), SP->getScopeLine(), 0, SP);
         }
-        return DebugLoc::get(SP->getLine(), 0, SP);
+        return DILocation::get(SP->getContext(), SP->getLine(), 0, SP);
     }
 
     return DebugLoc();
--- a/IGC/GenISAIntrinsics/GenIntrinsics.cpp
+++ b/IGC/GenISAIntrinsics/GenIntrinsics.cpp
@@ -188,7 +188,7 @@ static Type *DecodeFixedType(ArrayRef<Ge
   case IITDescriptor::SameVecWidthArgument: {
     Type *EltTy = DecodeFixedType(Infos, Tys, Context);
     Type *Ty = Tys[D.getArgumentNumber()];
-    if (VectorType *VTy = dyn_cast<VectorType>(Ty)) {
+    if (IGCLLVM::FixedVectorType *VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty)) {
       return IGCLLVM::FixedVectorType::get(EltTy, int_cast<unsigned int>(VTy->getNumElements()));
     }
     IGC_ASSERT_EXIT_MESSAGE(0, "unhandled");
@@ -199,7 +199,7 @@ static Type *DecodeFixedType(ArrayRef<Ge
   }
   case IITDescriptor::VecOfPtrsToElt: {
       Type *Ty = Tys[D.getArgumentNumber()];
-      VectorType *VTy = dyn_cast<VectorType>(Ty);
+      IGCLLVM::FixedVectorType *VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
       if (!VTy)
           IGC_ASSERT_EXIT_MESSAGE(0, "Expected an argument of Vector Type");
       Type *EltTy = cast<VectorType>(VTy)->getElementType();
@@ -418,7 +418,7 @@ static std::string getMangledTypeStr(Typ
     Result += "f";
   }
   else if (isa<VectorType>(Ty))
-    Result += "v" + utostr(cast<VectorType>(Ty)->getNumElements()) +
+    Result += "v" + utostr(cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements()) +
       getMangledTypeStr(cast<VectorType>(Ty)->getElementType());
   else if (Ty)
     Result += EVT::getEVT(Ty).getEVTString();
--- a/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
+++ b/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
@@ -4993,7 +4993,7 @@ void LLVM3DBuilder<preserveNames, T, Ins
     IGC_ASSERT(nullptr != vector->getType());
     IGC_ASSERT(vector->getType()->isVectorTy());
 
-    const unsigned count = (unsigned)llvm::cast<llvm::VectorType>(vector->getType())->getNumElements();
+    const unsigned count = (unsigned)llvm::cast<IGCLLVM::FixedVectorType>(vector->getType())->getNumElements();
     IGC_ASSERT(1 < count);
     IGC_ASSERT(count <= 4);
     IGC_ASSERT(count <= maxSize);
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/DerivedTypes.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/DerivedTypes.h
@@ -11,6 +11,7 @@ SPDX-License-Identifier: MIT
 
 #include "llvm/Config/llvm-config.h"
 #include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/Module.h"
 
 namespace IGCLLVM
 {
@@ -44,6 +45,15 @@ namespace IGCLLVM
         return false;
 #endif
     }
+
+    inline llvm::StructType *getTypeByName(llvm::Module *M, llvm::StringRef Name) {
+#if LLVM_VERSION_MAJOR >= 12
+        return llvm::StructType::getTypeByName(M->getContext(), Name);
+#else
+        return M->getTypeByName(Name);
+#endif
+    }
+
 }
 
 #endif
--- a/IGC/WrapperLLVM/include/llvmWrapper/Support/TypeSize.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Support/TypeSize.h
@@ -17,10 +17,14 @@ using namespace llvm;
 namespace IGCLLVM {
 #if LLVM_VERSION_MAJOR < 11
 inline unsigned getElementCount(unsigned EC) { return EC; }
-#else
+#elif LLVM_VERSION_MAJOR == 11
 inline ElementCount getElementCount(unsigned EC) {
   return ElementCount(EC, false);
 }
+#else
+inline ElementCount getElementCount(unsigned EC) {
+  return ElementCount::get(EC, false);
+}
 #endif
 } // namespace IGCLLVM
 
--- a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
@@ -26,7 +26,7 @@ namespace IGCLLVM
     {
         return llvm::createLoopUnrollPass(OptLevel, false, Threshold, Count, AllowPartial, Runtime, UpperBound, AllowPeeling);
     }
-#elif LLVM_VERSION_MAJOR == 9 || LLVM_VERSION_MAJOR == 10 || LLVM_VERSION_MAJOR == 11
+#elif LLVM_VERSION_MAJOR >= 9 && LLVM_VERSION_MAJOR <= 12
     inline static llvm::Pass * createLoopUnrollPass(
         int OptLevel = 2, int Threshold = -1, int Count = -1,
         int AllowPartial = -1, int Runtime = -1,
@@ -34,7 +34,7 @@ namespace IGCLLVM
     {
         return llvm::createLoopUnrollPass(OptLevel, false, false, Threshold, Count, AllowPartial, Runtime, UpperBound, AllowPeeling);
     }
-#elif LLVM_VERSION_MAJOR >= 12
+#else
     //DO NOT assume same function signature for all incoming llvm versions! Double check to upgrade!
 #error Not supported llvm version.
 #endif
--- a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Utils/LoopUtils.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Utils/LoopUtils.h
@@ -23,6 +23,14 @@ namespace IGCLLVM
         return llvm::InsertPreheaderForLoop(L, DT, LI, nullptr, PreserveLCSSA);
     }
 #endif
+
+    inline bool isInnermost(llvm::Loop *L) {
+#if LLVM_VERSION_MAJOR >= 12
+        return L->isInnermost();
+#else
+        return L->empty();
+#endif
+    }
 }
 
 #endif
--- a/IGC/common/igc_resourceDimTypes.h
+++ b/IGC/common/igc_resourceDimTypes.h
@@ -50,6 +50,11 @@ namespace IGC
             resourceDimTypeId == DIM_2D_TYPE || resourceDimTypeId == DIM_2D_ARRAY_TYPE ||
             resourceDimTypeId == DIM_3D_TYPE || resourceDimTypeId == DIM_CUBE_TYPE || resourceDimTypeId == DIM_CUBE_ARRAY_TYPE));
 
+#if LLVM_VERSION_MAJOR >= 12
+        llvm::LLVMContext& llvmCtx = module.getContext();
+        return llvm::StructType::getTypeByName(llvmCtx, ResourceDimensionTypeName[resourceDimTypeId]);
+#else
         return module.getTypeByName(ResourceDimensionTypeName[resourceDimTypeId]);
+#endif
     }
 }
\ No newline at end of file
